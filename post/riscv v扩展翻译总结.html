<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>v扩展翻译总结” | Chilh</title><meta name="author" content="chilh"><meta name="copyright" content="chilh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参数每个支持向量扩展的 hart 都有三个参数的定义  单个向量元素的最大长度ELEN （以bit为单位，下同），要求 ELEN ≥ 8，并且必须为2的幂。  2．向量寄存器的bit数VLEN，要求VLEN ≥ ELEN，并且必须是2的幂。 3．分段距离（The striping distance in bits）SLEN，要求必须为VLEN ≥ SLEN ≥ 32，并且必须为2的幂，不能大于2的">
<meta property="og:type" content="article">
<meta property="og:title" content="v扩展翻译总结”">
<meta property="og:url" content="https://chilh.top/post/riscv%20v%E6%89%A9%E5%B1%95%E7%BF%BB%E8%AF%91%E6%80%BB%E7%BB%93.html">
<meta property="og:site_name" content="Chilh">
<meta property="og:description" content="参数每个支持向量扩展的 hart 都有三个参数的定义  单个向量元素的最大长度ELEN （以bit为单位，下同），要求 ELEN ≥ 8，并且必须为2的幂。  2．向量寄存器的bit数VLEN，要求VLEN ≥ ELEN，并且必须是2的幂。 3．分段距离（The striping distance in bits）SLEN，要求必须为VLEN ≥ SLEN ≥ 32，并且必须为2的幂，不能大于2的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102035591.jfif">
<meta property="article:published_time" content="2024-11-10T12:30:33.000Z">
<meta property="article:modified_time" content="2024-11-10T12:57:38.525Z">
<meta property="article:author" content="chilh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102035591.jfif"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://chilh.top/post/riscv%20v%E6%89%A9%E5%B1%95%E7%BF%BB%E8%AF%91%E6%80%BB%E7%BB%93.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chilh","link":"链接: ","source":"来源: Chilh","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'v扩展翻译总结”',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-10 20:57:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"Jz34H84gllFAWP2o",ck:"Jz34H84gllFAWP2o"})</script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script> new LingQue.Monitor().init({id:"Jz365mPYN13QqIwT"});</script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/map/js/china.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fa fa-heartbeat"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102035591.jfif')"><nav id="nav"><span id="blog-info"><a href="/" title="Chilh"><span class="site-name">Chilh</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fa fa-heartbeat"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">v扩展翻译总结”</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-10T12:30:33.000Z" title="发表于 2024-11-10 20:30:33">2024-11-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-10T12:57:38.525Z" title="更新于 2024-11-10 20:57:38">2024-11-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/riscv/">riscv</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="v扩展翻译总结”"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a><font style="color:rgb(0,0,0);">参数</font></h2><p><font style="color:rgb(25, 27, 31);">每个支持向量扩展的 hart 都有三个参数的定义</font></p>
<ol>
<li>单个向量元素<font style="color:rgb(25, 27, 31);">的最大长度</font><em><font style="color:rgb(25, 27, 31);">ELEN</font></em><font style="color:rgb(25, 27, 31);"> （</font><font style="color:#DF2A3F;">以bit为单位</font><font style="color:rgb(25, 27, 31);">，下同），要求 </font><em><font style="color:rgb(25, 27, 31);">ELEN ≥ 8</font></em><font style="color:rgb(25, 27, 31);">，并且</font><font style="color:#DF2A3F;">必须为2的幂</font><font style="color:rgb(25, 27, 31);">。</font></li>
</ol>
<p><font style="color:rgb(25, 27, 31);">2．</font><strong><font style="color:#DF2A3F;">向量寄存器</font></strong><font style="color:rgb(25, 27, 31);">的bit数</font><em><font style="color:rgb(25, 27, 31);">VLEN</font></em><font style="color:rgb(25, 27, 31);">，要求</font><em><font style="color:rgb(25, 27, 31);">VLEN ≥ ELEN</font></em><font style="color:rgb(25, 27, 31);">，并且必须是2的幂。</font></p>
<p><font style="color:rgb(25, 27, 31);">3．分段距离（The striping distance in bits）</font><em><font style="color:rgb(25, 27, 31);">SLEN</font></em><font style="color:rgb(25, 27, 31);">，要求必须为</font><em><font style="color:rgb(25, 27, 31);">VLEN ≥ SLEN ≥ 32</font></em><font style="color:rgb(25, 27, 31);">，并且必须为2的幂，不能大于2的16次。</font></p>
<p><em><strong><font style="color:rgb(25, 27, 31);">Note：</font></strong>__<font style="color:rgb(25, 27, 31);">可以在平台配置文件上给这些参数设置其他约束，例如，要求 ELEN ≥ max（XLEN，FLEN），或要求最小 VLEN 值，或设置 SLEN 值，或要求 SLEN = VLEN。</font></em></p>
<p>有一种提议是允许 ELEN 随着 LMUL 变化，这样的话，会使得不一定满足 VLEN≥ELEN 。_</p>
<p><font style="color:rgb(25, 27, 31);">ISA 支持编写</font><font style="color:rgb(25, 27, 31);">代码，在某些约束下，这些代码可以在具有这些不同参数值的 harts 上执行。</font></p>
<h2 id="Vector-Extension-Programmer’s-Model"><a href="#Vector-Extension-Programmer’s-Model" class="headerlink" title="Vector Extension Programmer’s Model"></a><font style="color:rgb(0,0,0);">Vector Extension Programmer’s Model</font></h2><p> 向量扩展为基础的标量 RISC-V ISA 添加了 32 个向量寄存器，以及 7 个非特权 CSR（vstart, vxsat, vxrm, vcsr, vtype, vl, vlenb）  </p>
<p><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102056273.png"></p>
<h3 id="Vector-Registers"><a href="#Vector-Registers" class="headerlink" title="Vector Registers"></a><font style="color:rgb(0,0,0);">Vector Registers</font></h3><p><font style="color:rgb(0,0,0);"> 向量扩展为基础的标量 RISC-V ISA 添加了 32 个架构向量寄存器，v0 到 v31。每个向量寄存器具有 VLEN 位的状态。  </font></p>
<h3 id="Vector-Context-Status-in-mstatus"><a href="#Vector-Context-Status-in-mstatus" class="headerlink" title="Vector Context Status in mstatus"></a><font style="color:rgb(0,0,0);">Vector Context Status in mstatus</font></h3><p><font style="color:rgb(0,0,0);">msrarus中的[10:9]控制v扩展开关，如果没开但有v扩展指令，会有异常</font></p>
<h3 id="Vector-type-register-vtype"><a href="#Vector-type-register-vtype" class="headerlink" title="Vector type register, vtype"></a><font style="color:rgb(0,0,0);">Vector type register, vtype</font></h3><p>向量类型决定了每个向量寄存器中元素的组织，以及多个向量寄存器如何分组。vtype寄存器还指示如何处理向量结果中超过当前向量长度的元素。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727167100849-1d4f6359-91ed-47b8-afc5-2d17eeced384.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vtype的初衷是为了使vector扩展指令集能适配32位编码空间</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在执行一条vector指令之前,可以分别使用vset{i} vl{i}来设置vtype的field和vector length</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这两个值可以在后续指令中使用-+</font></li>
</ul>
<h4 id="Vector-selected-element-width-vsew-2-0-每个元素的大小"><a href="#Vector-selected-element-width-vsew-2-0-每个元素的大小" class="headerlink" title="Vector selected element width vsew[2:0] 每个元素的大小"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector selected element width vsew[2:0] 每个元素的大小</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这个field用来动态设置selected element width(SEW). 默认情况下,一个vector寄存器被分成VLEN/SEW 个元素.<br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727167500469-17a32667-bb96-4233-8974-065fa82c0f46.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727167510995-2f1b636f-620b-4236-8b6f-5fd0d82869ee.png"></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">SEW越大, 一个v寄存器中的元素个数越少</font></li>
</ul>
<h4 id="Vector-Register-Grouping-vlmul-2-0-一个group多少个寄存器"><a href="#Vector-Register-Grouping-vlmul-2-0-一个group多少个寄存器" class="headerlink" title="Vector Register Grouping (vlmul[2:0]) 一个group多少个寄存器"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Register Grouping (vlmul[2:0]) 一个group多少个寄存器</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">多个Vector寄存器可以被组成一个group。比如通用向量寄存器一共32个，设置LMUL为8，就可以将全部的通用寄存器分成4组，每组包含了8个连续的向量寄存器，这种分组的方式增加了向量寄存器组中元素的个数</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">LMUL默认是1, 具体实现时</font><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">必须支持LMUL=1,2,4,8</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vlmul是一个有符号数, </font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">LMUL=2</font><sup><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vlmul[2:0]</font></sup></li>
<li><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">SEW和lmul配置错误时会置位vtype中的vill bit</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">LMUL也可以是小数, 当存在混合长度的向量时, 小数LMUL可以增加vector寄存器的利用率. 具体来说当LMUL是小数时, 表示向量指令只操作一个向量的一部分. 例如VLEN=128, SEW=8, VLMAX表示一条向量指令所能操作的向量最大个数. 如果LMUL=1/8, 表示1/8个向量为一组, 则此时VLMAX=128/8/8 = 2, 也就是一条向量指令最多能操作一条向量的2个元素.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">LMUL为小数值时, 不是任意小数都能支持的, 最小支持</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">SEW</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">min</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">/ELEN</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">. 其中ELEN是最大支持的向量bit数, 需要保证LMUL乘上一个向量最大的元素个数大于等于1.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">下表给出了不同LMUL对应的group个数, VLMAX以及所用到的vector寄存器个数</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727168733130-cc5bdb41-d476-4457-94d3-e1acffc94856.png"></p>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">n如果小于1 ，一个group中只有一个寄存器，并且这个寄存器使用的bit数比实际的少<br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">lmul代表一个group包含几个寄存器（最少一个）</font></p>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">举例：</font></p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">VLEN=SLEN=128b
Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

SEW=8b      F E D C B A 9 8 7 6 5 4 3 2 1 0
SEW=16b       7   6   5   4   3   2   1   0
SEW=32b           3       2       1       0
SEW=64b                   1               0
SEW=128b                                  0
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一个group有一个vector寄存器，一个元素占sew大小</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">Example, VLEN=SLEN=128b, LMUL=1/4

Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

SEW=8b      - - - - - - - - - - - - 3 2 1 0
SEW=16b       -   -   -   -   -   -   1   0
SEW=32b           -       -       -       0
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一个group有4个寄存器</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">VLEN=SLEN=128b, SEW=32b, LMUL=4

Byte          F E D C B A 9 8 7 6 5 4 3 2 1 0
v4*n                3       2       1       0
v4*n+1              7       6       5       4
v4*n+2              B       A       9       8
v4*n+3              F       E       D       C
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Vector-Tail-Agnostic-and-Vector-Mask-Agnostic-vta-and-vma"><a href="#Vector-Tail-Agnostic-and-Vector-Mask-Agnostic-vta-and-vma" class="headerlink" title="Vector Tail Agnostic and Vector Mask Agnostic vta and vma"></a><font style="color:rgb(0,0,0);">Vector Tail Agnostic and Vector Mask Agnostic vta and vma</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">首先来看一下定义:</font><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量指令执行期间操作的元素索引可以分为四个不相交的子集。</font><ul>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">预启动元素（The prestart elements）:</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">是指索引小于</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vstart&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">寄存器初始值的元素。预启动元素不会引发异常，也不会更新目标向量寄存器。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">活跃元素（The active elements）:</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 指的是向量指令执行期间，在当前向量长度范围内的元素，并且在该元素位置启用了当前掩码。活动元素可以引发异常并更新目标向量寄存器组。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">非活跃元素（The inactive elements）:</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">指的是向量指令执行期间，在当前向量长度范围内的元素，但是在该元素位置禁用了当前掩码。 除非指定了masked agnostic（ </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vtype.vma = 1&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> ），否则非活跃元素不会引发异常，也不会更新任何目标向量寄存器组，在 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vtype.vma = 1&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 这种情况下，非活跃元素可能会被1覆盖。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">尾部元素（The tail elements）:</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 是超出当前向量长度设置的元素。 尾部元素不会引发异常，并且只在指定了tail agnostic尾部不可知性（vtype.vta = 1）的情况下，才会更新目标向量寄存器组，在这种情况下，尾部元素可能会被1覆盖。 当LMUL &lt;1时，尾部包含VLMAX之后的元素，这些元素保存在同一向量寄存器中。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">主体部分（body）:</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 用于表示活跃元素或非活跃元素的集合，即在预启动元素之后但在尾部元素之前。</font></li>
</ul>
</li>
</ul>
</li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727172020114-02341d50-503a-4279-8dc7-d511c51eca21.png"></li>
<li>这两个位分别在执行矢量指令的过程中修改了目标尾部元素和目标非活动掩码元素的行为。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727242781854-a91b42f8-0630-41ab-b281-6077c2613cfd.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对尾部元素的mask行为将被视为tail-agnostic, 无论vta如何配置.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">tail-agnostic: 尾部、</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">inactive </font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">元素可以保持不变 也可全置为1，可以不用管</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">undisturbed：尾部、</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">inactive </font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">元素要保持和之前 一致</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">agnostic策略实际上是为了兼容带有向量寄存器重命名的机器设计的. 如果只有undisturbed策略, 那么在寄存器重命名的时候就需要将旧的物理目的寄存器的内容复制到新的物理目的寄存器. 而设置为agnostic之后就可以忽略掉这部分无效的内容.</font></li>
<li><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">对于超标量的流水线，会采用寄存器重命名的方式，来避免WAW以及WAR这两类hazard。那程序的逻辑寄存器会映射到物理寄存器，映射后的对应关系会更新到重命名映射表中。那对于undisturbed策略，需要目的寄存器相应的元素保持原来的值。那么在用新的物理寄存器重命名时，还需要根据重命名映射表，查到原有的映射关系，再把这部分元素的值先读出来，写到重命名后的对应元素位置。这种方式对于压根儿不关心尾部元素集合或者被屏蔽元素集合的值的后续操作，就既降低了性能，又增加了不必要的功耗。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于普通的in-order流水线，可以采用这种undisturbed的策略。对于超标量的流水线，使用agnostic策略就显得更加明智。</font></li>
</ul>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">ta # Tail agnostic 
tu # Tail undisturbed 
ma # Mask agnostic 
mu # Mask undisturbed 
vsetvli t0, a0, e32, m4, ta, ma # Tail agnostic, mask agnostic 
vsetvli t0, a0, e32, m4, tu, ma # Tail undisturbed, mask agnostic 
vsetvli t0, a0, e32, m4, ta, mu # Tail agnostic, mask undisturbed 
vsetvli t0, a0, e32, m4, tu, mu # Tail undisturbed, mask undisturbed
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Vector-Type-Illegal-vill"><a href="#Vector-Type-Illegal-vill" class="headerlink" title="Vector Type Illegal vill"></a><font style="color:rgb(0,0,0);">Vector Type Illegal vill</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">标志之前的一次vsetvli指令下发了一次不支持的值</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当尝试执行一条vill位=1的指令时, 将会抛出非法指令异常</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vill=1时, vtype的其他部分需要被置为0</font></li>
</ul>
<h3 id="Vector-Length-Register-vl"><a href="#Vector-Length-Register-vl" class="headerlink" title="Vector Length Register, vl"></a><font style="color:rgb(29, 33, 41);">Vector Length Register, vl</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">只能通过vset{i}vl{i}指令赋值</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">定义了需一条向量指令更新的向量元素个数</font></li>
</ul>
<h3 id="Vector-Byte-Length-vlenb"><a href="#Vector-Byte-Length-vlenb" class="headerlink" title="Vector Byte Length, vlenb"></a><font style="color:rgb(29, 33, 41);">Vector Byte Length, vlenb</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);">vlenb = VLEN/8</font></li>
<li><font style="color:rgb(29, 33, 41);">该寄存器是给一些需要将VLEN以byte计数的场景，否则还需要手动计算byte数</font></li>
</ul>
<h3 id="Vector-Start-Index-CSR-vstart"><a href="#Vector-Start-Index-CSR-vstart" class="headerlink" title="Vector Start Index CSR, vstart"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Start Index CSR, vstart</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">定义了一条向量指令执行时的第一个元素在向量中的索引号</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一条向量指令结束时会将vstart归零</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vstart之前的向量值将保持undisturbed</font></strong></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果一条向量指令引发了非法异常，则不会修改vstart</font></strong></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vstart可以被非特权等级的代码修改， 但是非0的vstart可能使得向量指令运行变慢，所以不应该被应用程序修改</font></strong></li>
</ul>
<h3 id="Vector-Fixed-Point-Rounding-Mode-Register-vxrm"><a href="#Vector-Fixed-Point-Rounding-Mode-Register-vxrm" class="headerlink" title="Vector Fixed-Point Rounding Mode Register , vxrm"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Fixed-Point Rounding Mode Register , vxrm</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vxrm[1:0]为可读可写寄存器，该寄存器不仅有独立的寄存器地址，并且在vcsr寄存器中也有对应的域。该寄存器控制</font><strong><font style="color:#D22D8D;background-color:rgb(247, 248, 250);">定点舍入</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">模式，一共四种模式，分别是round-to-nearest-up（rnu）、round-to-nearest-even(rne)、round-down(rdn)、round-to-odd(rod)。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vxrm[1:0]寄存器通过单条csrwi指令写入值。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">假如源操作数是v，有低d bit数据要被截掉，那么做完rounding-mode之后的最终结果应该是(v&gt;&gt;d)+r，r就是根据不同的rounding mode得到的增量值。<br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">rnu：向距离近的方向进行舍入，当距离与两边都相等时，向上舍入。<br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">rne：向距离近的方向进行舍入，当距离与两边都相等时，向偶数方向舍入。<br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">rdn：向下舍入，直接取移位后的值。<br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">rod：舍入到奇数值方向。<br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">其中，v[d-1]表示权重位。当v[d-1]=0，表示距离舍的方向更近；当v[d-1]=1且v[d-2:0]=0时，距离舍入两个方向距离均相等；当v[d-1]=1，且v[d-2:0] != 0时，表示距离入的方向更近</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727244248320-62d070d1-a473-467a-88c3-1e8c8a0aa83a.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<h3 id="Vector-Fixed-Point-Saturation-Flag-vxsat"><a href="#Vector-Fixed-Point-Saturation-Flag-vxsat" class="headerlink" title="Vector Fixed-Point Saturation Flag vxsat"></a><font style="color:rgb(0,0,0);">Vector Fixed-Point Saturation Flag vxsat</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vxsat为可读可写寄存器，该寄存器不仅有独立的寄存器地址，并且在vcsr寄存器中也有对应的域。该寄存器有效表示输出结果做了饱和截位以适应目的寄存器格式。比如当运算发生正溢出时，保留结果为能取到的最大正值；当运算发生负溢出时，保留结果为负数最小值。</font></li>
</ul>
<h3 id="Vector-Control-and-Status-Register-vcsr"><a href="#Vector-Control-and-Status-Register-vcsr" class="headerlink" title="Vector Control and Status Register, vcsr"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Control and Status Register, vcsr</font></h3><p>包含以上两个寄存器：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727244363455-f68182a2-cbc8-483b-940e-72ae0a551394.png"></p>
<h3 id="State-of-Vector-Extension-at-Reset"><a href="#State-of-Vector-Extension-at-Reset" class="headerlink" title="State of Vector Extension at Reset"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">State of Vector Extension at Reset</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">推荐的做法是在reset时， vtype.vill=1， 其余位为0， 且vl=0</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">大部分向量单元需要一个初始的vset{i}vl{i}, 来复位vstart. vxrm和vxsat也需要在使用前复位</font></li>
</ul>
<font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">  
</font>

<h2 id="Mapping-of-Vector-Elements-to-Vector-Register-State"><a href="#Mapping-of-Vector-Elements-to-Vector-Register-State" class="headerlink" title="Mapping of Vector Elements to Vector Register State"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Mapping of Vector Elements to Vector Register State</font></h2><p>这块前半部分在前面介绍过了，现在详细举例子</p>
<h3 id="Mapping-for-LMUL-x3D-1"><a href="#Mapping-for-LMUL-x3D-1" class="headerlink" title="Mapping for LMUL = 1"></a><font style="color:rgb(0,0,0);">Mapping for LMUL = 1</font></h3><p>lmul=1, 一个group只有一个寄存器</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727244813641-ff98548f-7bf0-467d-841d-9c1123f4a53d.png"></p>
<h3 id="Mapping-for-LMUL-lt-1"><a href="#Mapping-for-LMUL-lt-1" class="headerlink" title="Mapping for LMUL < 1"></a><font style="color:rgb(0,0,0);">Mapping for LMUL &lt; 1</font></h3><p>只有LMUL*VLEN部分有效，其他部分是tail,需要vta设置</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727245187639-3d54ca2f-f04e-4804-b6d4-6a2afbb2c44c.png"></p>
<h3 id="Mapping-for-LMUL-gt-1"><a href="#Mapping-for-LMUL-gt-1" class="headerlink" title="Mapping for LMUL > 1"></a><font style="color:rgb(0,0,0);">Mapping for LMUL &gt; 1</font></h3><p>多个寄存器grouped</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727245238137-bd8c0d3e-3f55-4169-b347-c71e6112d8c6.png"></p>
<h3 id="Mapping-across-Mixed-Width-Operations"><a href="#Mapping-across-Mixed-Width-Operations" class="headerlink" title="Mapping across Mixed-Width Operations"></a><font style="color:rgb(0,0,0);">Mapping across Mixed-Width Operations</font></h3><p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量指令集可以支持元素混合位宽的操作</font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">通过动态修改vtype，应用程序可以操作多个精度不同的向量并且保持SEW/LMUL（元素总数）不变：</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">增加lmul的同时也得增加vtype，保证一个向量中元素个数不变</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727245482989-189af398-8239-4f71-b293-88b36609f505.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果要保持元素个数不变，只需要选定表格的一列，让LMUL随着SEW的变大成倍变大即可。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727245551518-29d4ed2c-2f59-441f-8f72-931f9d7228b6.png"></p>
<h3 id="Mask-Register-Layout"><a href="#Mask-Register-Layout" class="headerlink" title="Mask Register Layout"></a><font style="color:rgb(0,0,0);">Mask Register Layout</font></h3><p><font style="color:rgb(42, 43, 46);">无论SEW和LMUL如何，一个矢量掩码只占用一个矢量寄存器。</font></p>
<p><font style="color:rgb(42, 43, 46);">每个</font><strong><font style="color:#DF2A3F;">元素</font></strong><font style="color:rgb(42, 43, 46);">在一个掩码向量寄存器中分配一个掩码位。</font><strong><font style="color:#DF2A3F;">元素i的掩码位位于掩码寄存器的第i位，独立于SEW或LMUL。</font></strong></p>
<h2 id="Vector-Instruction-Formats"><a href="#Vector-Instruction-Formats" class="headerlink" title="Vector Instruction Formats"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Instruction Formats</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量指令格式会单独扩展一个格式：OP-V</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量的load和store指令沿用LOAD-FP和STORE-FP:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727245899442-3aebf4a8-fb85-437f-bbf6-954f0ca9b01f.png"></p>
<p>运算指令格式</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727245968390-63320747-1e2b-43ff-8bc0-775327ac026a.png"></p>
<p>vd/rd意思是某些指令用rd</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729147653776-5dd85204-bf36-4e24-937d-207b3810b559.png"></p>
<p>opfvv代表浮点指令op.vv</p>
<p>向量配置指令</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727246002069-9c085278-829c-4872-99c7-92c5e9423a1d.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1727246012020-6a7df375-9762-4452-a2d3-3f976891cd09.png"></p>
<ul>
<li><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">向量指令可以接收标量或者向量操作数，生成标量或者向量操作数</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">大多数向量指令可以通过mask实现条件或者非条件执行</font></li>
</ul>
<h3 id="Scalar-Operands"><a href="#Scalar-Operands" class="headerlink" title="Scalar Operands"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Scalar Operands</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">标量操作数可以是立即数，整数寄存器（x），浮点寄存器(f)或者一个vector寄存器的第0个元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">标量结果可以写入整数寄存器（x），浮点寄存器(f)或者一个vector寄存器的第0个元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">rv建议不要复用浮点寄存器和向量寄存器，降低了向量寄存器的压力，简化标量浮点设计</font></li>
</ul>
<h3 id="Vector-Operands"><a href="#Vector-Operands" class="headerlink" title="Vector Operands"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Operands</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">每个向量操作数都有一个effective element width (EEW), 一般情况下EEW=SEW.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">每个向量操作数都有一个effectiveLMUL (EMUL), 一般情况下EMUL=LMUL.</font></li>
<li><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">某些向量指令的源和目的向量具有相同的元素个数，但是元素位宽不同。此时EEW和EMUL就不等于SEW和LMUL, 但是EEW/EMUL = SEW/LMUL，这样才能保证元素个数相同。</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">例如：大部分拓宽的向量算数指令的源操作向量组EEW=SEW, EMUL=LMUL, 但是目的操作向量组的EEW=2<em>SEW, EMUL=2</em>LMUL</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量操作数或者结果操作数可能占用一个或多个向量寄存器（取决于EMUL), 如果占用多个，默认占用编号值较低的向量寄存器。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">以下情况可以将目的向量寄存器组直接用源向量寄存器组覆盖：</font><ol>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">目的EEW=源EEW</font></li>
<li><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">目的EEW&lt;源EEW, </font><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">并且发生覆盖的源向量是源向量寄存器组中的最低编号的向量寄存器</font></strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">。例如：LMUL=1, vnsrl.wi v0, v0, 3 is legal, but a destination of v1 is not</font></li>
</ol>
</li>
</ul>
<p>注：这个指令是将v0右移3位，存入v0</p>
<pre><code>3. &lt;font style="color:#DF2A3F;background-color:rgb(247, 248, 250);"&gt;目的EEW&gt;源EEW, 源EMUL至少是1， &lt;/font&gt;**&lt;font style="color:#DF2A3F;background-color:rgb(247, 248, 250);"&gt;并且发生覆盖的是目的向量寄存器组中的最高编号的向量寄存器&lt;/font&gt;**&lt;font style="color:#DF2A3F;background-color:rgb(247, 248, 250);"&gt;。例如：LMUL=8, vzext.vf4 v0, v6 is legal, but a source of v0, v2, or v4 is not&lt;/font&gt;
</code></pre>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量指令最多可以用8个向量寄存器，也就是是说EMUL&lt;=8. 如果一条向量指令需要超过8个向量寄存器，则会引发非法指令异常（实际上这种情况的指令编码空间是被保留的，目前不支持，可以被扩展）。 </font><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">例如，当 LMUL = 8 时，尝试进行加宽操作产生加宽的向量寄存器组将引发非法指令异常，因为这意味着 EMUL = 16。（2的幂次）</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">拓宽（Widened)标量值时，放在向量寄存器的第一个元素，EMUL=1.</font></li>
</ul>
<h3 id="Vector-Masking"><a href="#Vector-Masking" class="headerlink" title=" Vector Masking"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> Vector Masking</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">许多向量指令都支持掩码。 </font><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">被掩码（非活跃）的元素操作不产生异常</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">。 根据 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vtype&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 中的 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vma&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 位的设置，用_掩码不受干扰或掩码不可知_（mask-undisturbed or mask-agnostic）这两种策略来处理与掩码元素相对应的目标向量寄存器元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在掩码向量指令中，由向量寄存器 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;v0&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 保存用于控制掩码向量指令执行的掩码值。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">以后的向量扩展可能会提供更长的指令编码，并为完整的掩码寄存器说明符提供空间。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">只有当目标向量寄存器写入掩码值（如，comparisons）或归约的标量结果时，用于掩码向量指令的目标向量寄存器组才可以与源掩码寄存器（ v0 ）重叠。 否则，将引发非法指令异常。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">其他向量寄存器可用于保存有效的掩码值，并且提供掩码向量逻辑运算以执行谓词计算。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当使用比较结果写入掩码时，当前向量长度结束后的目标掩码位将根据 vtype中的 vta 位设置的尾部策略（ undisturbed or agnostic ）处理 </font></li>
</ul>
<h3 id="Mask-Encoding"><a href="#Mask-Encoding" class="headerlink" title="Mask Encoding"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(0,0,0);">Mask Encoding</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></h3><p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">掩码编码在指令( inst[25] )中的 vm 字段中，占一位。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728457110883-7b672720-79a8-4a83-bb36-02ea55e8683a.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量掩码在汇编代码中表示为另一个向量操作数，用 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;.t&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 表示当 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;v0.mask[i]&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 为 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;1&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 时是否发生操作。如果未指定掩码操作数，则假定为未掩码的向量执行（ </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vm = 1&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> ）。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728457197569-04a9561c-259c-4166-900d-9810be708598.png"></p>
<h3 id="Prestart-Active-Inactive-Body-and-Tail-Element-Denitions"><a href="#Prestart-Active-Inactive-Body-and-Tail-Element-Denitions" class="headerlink" title="Prestart, Active, Inactive, Body, and Tail Element Denitions"></a><font style="color:rgb(0,0,0);">Prestart, Active, Inactive, Body, and Tail Element Denitions</font></h3><h4 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h4><ol>
<li><strong>预启动元素（Prestart Elements）</strong>：<ul>
<li>索引小于 <code>vstart</code> 的元素。</li>
<li>不会引发异常，也不会更新目标向量寄存器。</li>
</ul>
</li>
<li><strong>主体元素（Body Elements）</strong>：<ul>
<li>索引在 <code>vstart</code> 和当前向量长度 <code>vl</code> 之间。</li>
<li>分为两部分：<ul>
<li><strong>活跃元素（Active Elements）</strong>：<ul>
<li>在主体内且掩码启用的元素。</li>
<li>可以引发异常，并更新目标向量寄存器。</li>
</ul>
</li>
<li><strong>非活跃元素（Inactive Elements）</strong>：<ul>
<li>在主体内但掩码禁用的元素。</li>
<li>不引发异常，除非指定了掩码无关（<code>vtype.vma=1</code>），此时可能被覆盖为 1。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>尾部元素（Tail Elements）</strong>：</li>
</ol>
<ul>
<li>索引超出当前向量长度 <code>vl</code> 的元素。</li>
<li>不引发异常，且默认情况下不会更新目标向量寄存器，除非指定了尾部无关（`vtype.vta=1），此时可能被覆盖为 1 或指令的结果（除了掩码加载指令）。</li>
<li>当 <code>LMUL &lt; 1</code> 时，尾部包括超过 <code>VLMAX</code> 的元素。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728457666990-b1477460-0b8b-4cfd-9166-1f45280c524e.png"></li>
</ul>
<h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><ul>
<li>当 <code>vstart ≥ vl</code> 时，没有主体元素，也不会更新任何目标向量寄存器，包括尾部元素。</li>
<li>当 <code>vl=0</code> 时，无元素会更新目标寄存器，无论 <code>vstart</code> 的值。</li>
<li>写入 <code>x</code> 寄存器或 <code>f</code> 寄存器的指令即使在 <code>vstart ≥ vl</code> 或 <code>vl=0</code> 时仍然执行。</li>
<li>某些指令如 <code>vslidedown</code> 和 <code>vrgather</code> 可能会读取超出 <code>vl</code> 或 <code>VLMAX</code> 的索引。在源向量寄存器中，索引超过 <code>VLMAX</code> 时通常返回值 0。</li>
</ul>
<h2 id="Configuration-Setting-Instructions-vsetvli-x2F-vsetivli-x2F-vsetvl"><a href="#Configuration-Setting-Instructions-vsetvli-x2F-vsetivli-x2F-vsetvl" class="headerlink" title="Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)"></a><font style="color:rgb(0,0,0);">Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Application vector length (AVL)</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">处理大量元素的一种常见方法是“stripmining”，在这种方法中，每次循环迭代都会处理一定数量的元素，迭代会一直持续到所有元素都被处理完毕。RISC-V向量规范为这种方法提供了直接、可移植的支持。应用程序将待处理的元素总数（应用程序向量长度或AVL）指定为vl的候选值，硬件则通过一个通用寄存器响应，根据微架构实现和vtype设置，提供每次迭代中硬件将处理的（通常更小的）元素数量（存储在vl中）。一个简单的循环结构，如stripmining示例和SEW的更改所示，描绘了代码如何轻松地跟踪剩余的元素数量和硬件每次迭代处理的数量。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">应用程序可能会处理一个包含大量元素的vector, 硬件需要将其分为多个loop才能做完. 这里应用程序给出的真实的vector 元素个数就是AVL, 硬件每次处理的实际元素个数就是vl寄存器.</font></li>
<li><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">这条指令是</font>****<font style="color:#DF2A3F;">根据应用程序需要快速配置vl和vtype中的值。vset{i}vl{i}指令根据其参数设置vtype和vl CSR，并将vl的新值写入rd。</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vsetvli 指令根据其参数设置 vtype 和 vl CSRs，并将 vl 的新值写入 rd。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728464412862-a3859437-530b-4d69-94b3-a7dfcbd687ba.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728464418622-92c4c665-6381-455f-af2a-b9706b0bf685.png"></p>
<h3 id="vtype-encoding"><a href="#vtype-encoding" class="headerlink" title="vtype encoding"></a><font style="color:rgb(0,0,0);">vtype encoding</font></h3><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728464444808-266ebdc0-c598-42d8-8a41-4f89fa4f8cea.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728464834491-d489af20-f0e3-408c-a514-457219c9b28c.png"></p>
<p><font style="color:rgb(77, 77, 77);">新的vtype设置被编码在vsetvli和vsetivli的立即字段中，以及vsetvl的rs2寄存器中。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728464921149-619c5f5c-d170-4524-bc76-83f84a490307.png"></p>
<p>每条指令设置sew和lmul</p>
<ul>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vsetvl</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">指令与</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vsetvli</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">稍有不同, vsetvl从rs2寄存器拿到vtype值,</font><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">而不是直接给出</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">. 这可以用来进行上下文恢复.</font></li>
</ul>
<h3 id="AVL-encoding"><a href="#AVL-encoding" class="headerlink" title="AVL encoding"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">AVL encoding</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">根据setivli指令的rd和rs寄存器的情况, 有以下三种模式:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728465150247-3e58bab3-ee23-470e-85b4-79836c7f5aea.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<ul>
<li>当rs1不是x0时，AVL是存储在由rs1指定的x寄存器中的无符号整数，新的vl值也将写入由rd指定的x寄存器。</li>
<li>当rs1=x0但rd!=x0时，使用最大的无符号整数值(~0)作为AVL，并将结果VLMAX写入vl以及由rd指定的x寄存器。</li>
<li>当rs1=x0且rd=x0时，指令的操作就像是将vl中的当前向量长度用作AVL，并将结果值写入vl，但不写入目标寄存器。这种形式只能在VLMAX（因此vl）实际上没有因新的SEW/LMUL比率而改变时使用。如果使用新的SEW/LMUL比率会导致VLMAX发生变化，则保留该指令的使用。在这种情况下，实现可能会设置vill。</li>
<li>这种指令的最后一种形式允许在保持当前vl的同时更改vtype寄存器，前提是VLMAX没有减少。这种设计是为了确保vl始终为当前的vtype设置持有合法值。当前的vl值可以从vl CSR中读取。如果新的SEW/LMUL比率导致VLMAX缩小，则此指令可能会减少vl值，因此这种情况已被保留，因为这并不清楚这是一个普遍有用的操作，而且实现可以假设此指令不会更改vl以优化其微架构。</li>
<li>对于vsetiv li指令，AVL在rs1字段中编码为5位零扩展立即数（0-31）。</li>
</ul>
<p><font style="color:#DF2A3F;">请注意，vsetiv li的AVL编码与常规CSR立即数值的编码相同。当向量寄存器内部向量的维度较小且已知时，vsetiv li指令可以提供更紧凑的代码，在这种情况下，没有stripmining开销。</font></p>
<h3 id="Constraints-on-Setting-vl"><a href="#Constraints-on-Setting-vl" class="headerlink" title="Constraints on Setting vl"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Constraints on Setting vl</font></h3><p><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vset{i}vl{i}&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">指令首先根据 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vtype&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 参数，设定 VLMAX ，然后设置</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">服从以下约束：</font></p>
<ol>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;AVL ≤ VLMAX&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> ，则 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl = AVL&lt;/font&gt;</code></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;AVL &lt; (2 * VLMAX)&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，则</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;ceil(AVL / 2) ≤ vl ≤ VLMAX&lt;/font&gt;</code></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;AVL ≥ (2 * VLMAX)&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，则 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl = VLMAX&lt;/font&gt;</code></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果输入相同的 AVL 和 VLMAX 值，则任何实现中，</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;v1&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 都是确定的</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">满足之前提及的规则：</font><ol>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;AVL = 0&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，则 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl = 0&lt;/font&gt;</code></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;AVL &gt; 0&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl &gt; 0&lt;/font&gt;</code></li>
<li><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl ≤ VLMAX&lt;/font&gt;</code></li>
<li><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl ≤ AVL&lt;/font&gt;</code></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">从 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 中读取的值（用作 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vsetvl{i}&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 的 AVL 参数时）会在 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 中产生相同的值，前提是所得的 VLMAX 等于读取</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">时的 VLMAX 值。</font></li>
</ol>
</li>
</ol>
<ul>
<li><p><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">的设置规则足够严格，可以在寄存器溢出和 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;AVL ≤ VLMAX&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">时上下文交换的情况下保护 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 的行为，但又足够灵活，确保能够提高 AVL&gt; VLMAX 时的向量通道利用率。</font></p>
</li>
<li><p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当AVL介于VLMAX和VLMAX*2时， 可以保证vl=AVL的一半（向上取整），通过两次loop实现AVL.</font></p>
</li>
</ul>
<h3 id="Example-of-stripmining-and-changes-to-SEW"><a href="#Example-of-stripmining-and-changes-to-SEW" class="headerlink" title="Example of stripmining and changes to SEW"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Example of stripmining and changes to SEW</font></h3><p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">为了在混合宽度操作上提供高吞吐量，可以动态更改 SEW 和 LMUL 的设置。</font><br><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728527966443-fe4bfae8-73fc-445d-aa1b-706bcabd2d81.png"></p>
<h2 id="Vector-Loads-and-Stores"><a href="#Vector-Loads-and-Stores" class="headerlink" title="Vector Loads and Stores"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Loads and Stores</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">带mask的load不会更新非活跃的元素,除非被标记为不可知的(agnostic, vtype.vma=1)</font></li>
</ul>
<h3 id="Vector-Load-x2F-Store-Instruction-Encoding"><a href="#Vector-Load-x2F-Store-Instruction-Encoding" class="headerlink" title="Vector Load/Store Instruction Encoding"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Load/Store Instruction Encoding</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量load/store复用标量浮点数的load/store(LOAD-FP/STORE-FP)</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量的加载和存储编码重新利用了标量浮点加载/存储12位立即数字段的一部分，以提供进一步的向量指令编码，其中位25保留了标准向量掩码位:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728529559128-b0dded2b-a678-495a-bceb-376d8beb0625.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量内存操作直接对指令中要静态传输的数据的 EEW 进行编码，从而减少混合宽度操作时，访问内存时 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vtype&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 的改变次数。 索引操作在指令中使用显式 EEW 编码来设置所使用索引的大小，并且用 SEW / LMUL 的值指定数据宽度。</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Vector-Load-x2F-Store-Addressing-Modes"><a href="#Vector-Load-x2F-Store-Addressing-Modes" class="headerlink" title="Vector Load/Store Addressing Modes"></a><font style="color:rgb(0,0,0);">Vector Load/Store Addressing Modes</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></h3><p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">基本向量扩展支持单位跨步（unit-stride），跨步（strided）和索引（indexed）寻址模式。向量加载/存储的基址寄存器和步幅取自GPR </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;x&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 寄存器。</font><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">unit-stride就是向量元素在内存中的排布就是挨个的, 可以直接一个一个拿出来</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">stride是为了按照一个固定间隔取向量元素的方式. 比如在进行两个矩阵相乘A*B, A的一行会跟B的一列做向量乘. A和B在内存中都是按行存储的. A做向量乘时,可以挨个拿出来放到向量寄存器, 而B, 需要按列取出, 所以需要每隔一行元素个数取一个元素, 放到向量寄存器, 才能取出B的一列. 此时就需要用到stride模式了.</font><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">stride模式下, 每次取元素的步长是以byte为最小单位计数的. 步长值存储在rs2表示的寄存器中</font></li>
</ul>
</li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">indexed模式是最精细的, 可以精确控制向量寄存器中的某个元素从哪里来. 在取每个元素时, 用vs2向量寄存器的值在mem中索引要取出的元素.</font><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">indexed模式下, 存放元素的向量寄存器组的EEW= SEW, EMUL=LMUL.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">存放index(offset)的向量寄存器组vs2对应的EEW在指令中进行了编码. 而EMUL则可以计算出来: EMUL=(EEW/SEW)*LMUL. 其实就是用数据向量的元素个数与index向量的EEW来计算组数.</font></li>
</ul>
</li>
</ul>
</li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量偏移量操作数被视为字节地址偏移量的向量。如果向量偏移量小于 XLEN，则在将它们添加到基本有效地址之前，先将它们加零扩展到XLEN。如果向量偏移量大于 XLEN，则在地址计算中使用最低有效的 XLEN 位。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量寻址模式使用2位</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;mop[1:0]&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 字段进行编码:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728530059913-b5206ad8-caba-4c20-ab59-c1cfadbd0927.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量的索引操作具有两种形式，有序的和无序的。无序的索引(mop!=11)存储操作不保存元素顺序。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于需要强访存顺序依赖的区域,例如IO, 需要使用ordered indexed 方式才能保证顺序</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">其他的 unit-stride 向量寻址模式在 unit-stride 加载和存储指令编码中分别使用5位</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;lumop&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">和</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;sumop&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">字段编码。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728530151920-5d56331e-fb7b-4854-8c41-120278d789fe.png"></p>
<ul>
<li><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;nf[2:0]&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">字段编码每个段（segment）中的字段数。对于常规向量的加载和存储，</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;nf&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">= 0，表示在每个元素位置的向量寄存器组和内存之间移动单个值。</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;nf&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">字段中较大的值用于访问段中的多个连续字段（关于段的描述参见7.8节）。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;nf&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">字段替换了地址偏移量字段中的相同位。偏移量可以用单个标量整数计算代替，而段加载/存储添加了更强大的原语，可以将项目移入和移出内存。</font></li>
<li><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;nf[2:0]&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">字段还对整个向量寄存器的数量进行编码，以针对整个向量寄存器的加载/存储指令进行传输。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">后面会介绍nf的具体内容。</font></li>
</ul>
<h4 id="Vector-Load-x2F-Store-Width-Encoding"><a href="#Vector-Load-x2F-Store-Width-Encoding" class="headerlink" title="Vector Load/Store Width Encoding"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Load/Store Width Encoding</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量的加载和存储直接将 EEW 编码在指令中。EMUL 的计算公式为：EMUL =（EEW / SEW）* LMUL 。如果 EMUL 超出范围（ EMUL&gt; 8 或 EMUL &lt;1/8 ），则会触发非法指令异常。向量寄存器组必须存在能指明所选 EMUL 是否合法的寄存器，否则会触发非法指令异常。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728530892015-31fce98a-24d8-4ab3-96e1-06390715a3e3.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Mem bits（内存位）是内存中访问的每个元素的大小。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Reg bits（寄存器位）是寄存器中访问的每个元素的大小。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">index bits (索引位) 是索引向量中每个元素的大小。</font></li>
<li><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;mew&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">位（</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;inst[28]&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">）扩展了128位及超过128位的内存大小。</font></li>
</ul>
<h4 id="Vector-Unit-Stride-Instructions"><a href="#Vector-Unit-Stride-Instructions" class="headerlink" title="Vector Unit-Stride Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Unit-Stride Instructions</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728530927582-6d45976e-274f-4493-a7bd-14e7bc08ac92.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">此外， 额外的unit-stride mask 访存指令需要被用来将mask值导入或导出。这个操作与unmasked byte load/store类似（EEW=8). 不同之处是等效向量长度evl=ceil(vl/8) ， 也就是说没个bit管一个被masked元素. 目的向量寄存器中的剩余部分是tail-agnostic的</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">下面是mask load/store指令:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728530951420-e8d56c16-c92c-40de-9a35-fe1584726b23.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">实际上vlm.v与width=0的vle8.v指令相同， 区别是lumop和sumop不同。</font></li>
</ul>
<h4 id="Vector-Strided-Instructions"><a href="#Vector-Strided-Instructions" class="headerlink" title="Vector Strided Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Strided Instructions</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728530981618-e9858143-4fe5-4c7a-a098-bcca6b39c5d5.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持负数stride和0-stride</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">stride指令中元素的访问彼此之间无序</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当rs2=x0时，允许但不要求实现执行比活动元素数量更少的内存操作，并且可以在同一静态指令的不同动态执行中执行不同数量的内存操作。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果rs2!=x0, 但是rs2的值=0, 则每个active的元素都必须进行一次访问, 不过顺序可以不固定.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果确定每个元素都执行内存访问，编译器必须注意当立即步长为0时，不要对rs2使用x0形式。</font></li>
</ul>
<h4 id="Vector-Indexed-Instructions"><a href="#Vector-Indexed-Instructions" class="headerlink" title="Vector Indexed Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Indexed Instructions</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728531358876-a0bb2f88-4aae-42d5-8590-2e8baa49ecf7.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">上述汇编中ei8,ei16等表示8,16都是表示index的位宽,而不是data的. data的位宽由SEW指定.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">带u的就是unordered, 带o的是ordered.</font></li>
</ul>
<h4 id="Unit-stride-Fault-Only-First-Loads"><a href="#Unit-stride-Fault-Only-First-Loads" class="headerlink" title="Unit-stride Fault-Only-First Loads"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Unit-stride Fault-Only-First Loads</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Unit-stride Fault-Only-First Loads是用来对那些退出条件依赖数据的循环进行向量化(例如while循环)</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一般情况下这些指令跟普通的unit访存指令相当, 但是会在向量的第一个元素触发了异常之后执行陷入操作</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果其他元素（非第一个元素）触发了异常，那么对应的陷入将不发生， 向量长度vl减少为这个元素的index大小。且不会更新向量寄存器中发生异常的元素及其之后的元素。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728531405872-33b85010-5d94-4d0f-b04f-29ab3f218e59.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728531412583-b8965c8a-6ec9-4c8a-8a47-d0e3b7f13ff4.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">即使未引发异常，操作中也可以处理少于</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">个元素并相应地减少</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，但是如果</font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vstart&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">= 0和 </font><code>&lt;font style="color:rgb(21, 167, 167);background-color:rgb(247, 248, 250);"&gt;vl&lt;/font&gt;</code><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">&gt; 0，则必须处理至少一个元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当仅故障优先指令由于中断而发生陷阱时，实现不应减少 vl 而应设置 vstart 值。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当仅故障第一指令将在第一个之后触发元素上的调试数据观察点陷阱时，实现不应减少 vl 而是应触发调试陷阱，否则事件可能会丢失</font></li>
</ul>
<h4 id="Vector-Load-x2F-Store-Segment-Instructions"><a href="#Vector-Load-x2F-Store-Segment-Instructions" class="headerlink" title="Vector Load/Store Segment Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Load/Store Segment Instructions</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">segment指令将多个连续内存区域与若干连续的向量寄存器进行数据搬运</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">“段”反映了移动的项目是具有同质元素的子数组。这些操作可用于在内存和寄存器之间转置数组，并且可以通过将结构中的每个字段解包到单独的向量寄存器中来支持对“结构数组”数据类型的操作。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">nf是3bit的整数, 表示段中的Nfields-1.</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728538596112-6f34d2e7-e3dc-4139-8f5f-7ac42d5bad58.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">EMUL 设置必须使 EMUL * NFIELDS ≤ 8。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意乘积 EMUL * NFIELDS 表示将被分段加载或存储指令触及的底层向量寄存器的数量。这个约束使得这个总数不大于架构寄存器文件的 1/4，并且与 EMUL=8 的常规操作相同。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">每个字段将保存在连续编号的向量寄存器组中。当 EMUL&gt;1 时，每个字段将占用多个连续编号的向量寄存器中保存的向量寄存器组，并且每个字段的向量寄存器组必须遵循通常的向量寄存器对齐约束（例如，当 EMUL=2 和 NFIELDS=4 时，每个域的向量寄存器组必须从偶数向量寄存器开始，但不必从 8 个向量寄存器号的倍数开始）。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果段加载或存储访问的向量寄存器编号将增加超过 31，则保留指令编码。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意此约束是为了帮助实现与未来可能更长的指令编码的前向兼容性，该指令编码具有更多可寻址向量寄存器。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vl 寄存器给出要移动的段数，它等于传送到每个向量寄存器组的元素数。mask也应用于整个段的级别。 对于段加载和存储，用于访问每个段内的字段的各个内存访问相对于彼此是无序的，即使对于有序索引段加载和存储也是如此。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vstart 值以整个段为单位。如果在访问段期间发生陷阱，则在采取陷阱之前是否执行故障段的访问子集是由实现定义的。</font></li>
</ul>
<h4 id="Vector-Unit-Stride-Segment-Loads-and-Stores"><a href="#Vector-Unit-Stride-Segment-Loads-and-Stores" class="headerlink" title="Vector Unit-Stride Segment Loads and Stores"></a><font style="color:rgb(0,0,0);">Vector Unit-Stride Segment Loads and Stores</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Unit-Stride Segment Loads and Stores将打包的连续段移动到多个目标向量寄存器组中。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">可以用于一些结构体: RGB, complex数据等的向量存取</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在段包含具有不同大小字段的结构的情况下，软件稍后可以在段加载将数据带入向量寄存器后使用附加指令解压缩单个结构字段。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vlseg/vsseg 分别用于单位跨度段的加载和存储。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728538689591-8d66b6f1-3ff1-455e-8394-20352b588e04.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于加载（ loads），vd 寄存器将保存从段加载的第一个字段。对于存储，读取 vs3 寄存器以提供要存储到每个段的第一个字段。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728538709051-d12d286b-97e4-4236-89aa-83b30acf543c.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">上图中, 第一个是加载RGB三个像素点组成的segment到向量寄存器的例子. 其中nfields=3, eew=8.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">也有单元步长指令的仅故障优先版本:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728538729471-22f7080e-8f5d-4c09-baa7-d3b429a527de.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于仅故障的第一个段加载，如果在访问段的过程中检测到异常，则无论元素索引是否为零，是否加载段的子集都是实现定义的。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这些指令可能会在报告陷阱的点或修剪向量长度的点之后覆盖目标向量寄存器组元素。</font></li>
</ul>
<h4 id="Vector-Strided-Segment-Loads-and-Stores"><a href="#Vector-Strided-Segment-Loads-and-Stores" class="headerlink" title="Vector Strided Segment Loads and Stores"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Strided Segment Loads and Stores</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">每个segment之间间隔byte-stride时用这种指令</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728539353305-ba5532c0-d342-428b-8f3c-7089fc13b19e.png"></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">例如上面第一个例子, x5是基地址, x6就是stride. 因为有3个seg, 所以会占用3个vector group. 这里需要注意的是, 3个segment实际上在内存中应该是一个结构体, 所以每个segment在内存上是连续的, 所以这里三个seg的address是连续的, 但是会放在三个不同的vector reg group</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对一个segment中的fields的访问顺序是随意的.</font></li>
</ul>
<h4 id="Vector-Indexed-Segment-Loads-and-Stores"><a href="#Vector-Indexed-Segment-Loads-and-Stores" class="headerlink" title=" Vector Indexed Segment Loads and Stores"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> Vector Indexed Segment Loads and Stores</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">indexed访存指令的segment版本.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">同样包含ordered和unordered. 但是即使是ordered, 对一个segment中的不同field的访问也是无序的</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">同样的, indexed访存指令中, 显式给出的是index的EEW, 例如ei32, 表示index是32bit. data向量的EEW=SEW, EMUL = LMUL</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728539354033-eefde5b1-1d4b-4d37-b719-767418704510.png"></li>
</ul>
<h4 id="Vector-Load-x2F-Store-Whole-Register-Instructions"><a href="#Vector-Load-x2F-Store-Whole-Register-Instructions" class="headerlink" title="Vector Load/Store Whole Register Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Load/Store Whole Register Instructions</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728539353592-17887765-c810-45d9-b852-877eaffea5ac.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这类load/store指令会操作全部的向量寄存器组</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这类指令可以在向量寄存器当前内容的长度未知时使用， 或者某些修改vl和vtype代价较高的场景。例如：</font><ol>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">compiler register spills（当寄存器使用超出物理寄存器个数，会将一部分寄存器搬到主存中，为新变量腾出寄存器空间）</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">用向量寄存器传值的向量函数</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">中断处理</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">操作系统的上下文切换</font></li>
</ol>
</li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">load执行包含mew字段，表示EEW, width字段的含义与[[#7.3. Vector Load/Store Width Encoding]] 中所述相同。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 因为寄存器中字节布局与内存中字节布局相同，所以无论EEW如何，相同的数据都会写入目标寄存器组。因此，仅提供 EEW=8 变体就足够了。提供了完整的 EEW 变体集，以便编码的 EEW 可用作指示目标寄存器组接下来将使用此 EEW 访问的提示，这有助于在内部重新排列数据的实现。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量整个寄存器存储指令的编码类似于 EEW=8 的元素的未屏蔽单元步长存储。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">nf 字段使用 NFIELDS 编码对要加载和存储的向量寄存器数量进行编码（图 NFIELDS 编码）。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">寄存器的编码数量必须是 2 的幂，并且向量寄存器数量必须与向量寄存器组对齐，否则保留指令编码。</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">NFIELDS 表示要传输的向量寄存器的数量</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，在基数之后依次编号。仅支持 NFIELDS 值 1、2、4、8，保留其他值。当传输多个寄存器时，编号最小的向量寄存器保存在编号最小的内存地址中，并且连续的向量寄存器编号连续放置在内存中。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">无论 vtype 和 vl 中的当前设置如何，指令都以有效向量长度 evl=NFIELDS*VLEN/EEW 运行。如果 vstart ≥ vl , 则还是可能会写入元素（之前的指令中如果vstart≥ vl ，不会写入任何元素）。相反，如果 vstart ≥ evl 则不写入任何元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这些指令的操作类似于未屏蔽的单位步长加载和存储指令，基地址在由 rs1 指定的标量 x 寄存器中传递。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果基地址未自然对齐到以字节为单位的编码 EEW 的大小 (EEW/8) 或以字节为单位的实现的最小支持 SEW 大小(SEWmin/8)中的较大者，则允许实现在整个寄存器加载和存储时引发</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">未对齐的地址异常</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 允许基于与编码的 EEW 不对齐而引发未对齐异常可简化这些指令的实现。一些子集实现可能不支持较小的 SEW 宽度，因此即使大于编码的 EEW，也允许报告支持的最小 SEW 的未对齐异常。例如，一个极端的非标准实现可能有 SEWmin&gt;XLEN。软件环境可以强制要求最低对齐要求来支持 ABI。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">下面是实际的伪代码示例：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728539354005-89039203-8d2e-4700-bf08-776238e56fc8.png"></p>
<ul>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 对于不支持的 EEW 值，实现应该在 vl<nf>r指令上引发非法指令异常。</nf></font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">我们已经考虑添加一个完整的寄存器掩码加载指令（</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vl1rm.v</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">），但决定从初始扩展中省略。主要目的是通知微架构数据将用作掩码。使用以下代码序列可以达到相同的效果，其成本最多为四条指令。其中，第一个可能会被删除，因为 vl 通常已经在一个标量寄存器中，如果后面的向量指令需要一个新的 SEW/LMUL，最后一个可能已经存在。因此，在最好的情况下，只需要两条指令（其中只有一条执行向量运算）来合成专用指令的效果：</font><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728539353978-a73ad7d8-fe01-4abb-bb4c-808df2f38e2e.png"></li>
</ul>
</li>
</ul>
<h2 id="Vector-Memory-Alignment-Constraints"><a href="#Vector-Memory-Alignment-Constraints" class="headerlink" title="Vector Memory Alignment Constraints"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Memory Alignment Constraints</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果向量内存指令访问的元素与元素的大小不自然对齐，则该元素被成功传输或在该元素上引发地址未对齐异常。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对未对齐的向量内存访问的支持与对未对齐的标量内存访问的支持在一个具体实现中是独立开来的。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 一个实现可能没有、有一个或两个标量和向量内存访问支持硬件中的部分或全部未对齐访问。应定义一个单独的 PMA 以确定相关地址范围内是否支持向量未对齐访问。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">矢量未对齐内存访问遵循与标量未对齐内存访问相同的原子性规则。</font></li>
</ul>
<h2 id="Vector-Memory-Consistency-Model"><a href="#Vector-Memory-Consistency-Model" class="headerlink" title="Vector Memory Consistency Model"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Memory Consistency Model</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量内存指令在本地 hart 上按程序顺序执行。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量存储器指令在指令级遵循 RVWMO。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">除了vector indexed-ordered loads and stores,，指令中的元素操作是无序的。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector indexed-ordered 分别按元素顺序从/向内存加载和存储读取和写入元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">受向量长度寄存器 vl 影响的指令对 vl 具有控制依赖性，而不是数据依赖性。类似地，mask向量指令对源mask寄存器具有控制依赖性，而不是数据依赖性。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 将向量长度和掩码视为控制而不是数据通常与相应标量代码的语义相匹配，其中通常会使用</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">分支指令</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">。将掩码视为控制允许掩码向量加载指令在知道掩码值之前访问内存，而无需错误推测恢复机制。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">目前未定义提议的 RVTSO 内存模型（Ztso 扩展）下的向量内存指令的行为。</font></li>
</ul>
<h2 id="Vector-Arithmetic-Instruction-Formats"><a href="#Vector-Arithmetic-Instruction-Formats" class="headerlink" title="Vector Arithmetic Instruction Formats"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Arithmetic Instruction Formats</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">矢量算术指令使用与 OP-FP 相邻的新主操作码 (OP-V = 10101112)。三位 funct3 字段用于定义向量指令的子类别。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">OP-V 主要操作码下向量算术指令的格式:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728540608196-6b0233a6-3802-42f3-892e-058a62681de0.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<h3 id="Vector-Arithmetic-Instruction-encoding"><a href="#Vector-Arithmetic-Instruction-encoding" class="headerlink" title="Vector Arithmetic Instruction encoding"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Arithmetic Instruction encoding</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">funct3编码了操作类型和源地址<br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728540696282-3806f261-9fab-4d8e-8543-31619b08f34f.png"></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">根据操作码，使用无符号或二进制补码有符号整数算术执行整数运算。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在本讨论中，定点运算被认为是整数运算。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">所有标准向量浮点算术运算都遵循 IEEE-754/2008 标准。</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">所有向量浮点运算都使用 frm 寄存器中的动态舍入模式</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">。当任何向量浮点指令使用 包含无效的舍入模式的frm 字段时，即使它是不依赖于舍入模式的指令，或者其vl=0 时，又或者此时vstart ≥ vl 时，都是非法的。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 所有向量浮点代码都依赖于 frm 中的有效值。</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当舍入模式无效时，具体实现可以使所有向量 FP 指令报告异常，以简化控制逻辑。</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vector-vector运算从分别由 vs2 和 vs1 指定的向量寄存器组中获取两个操作数向量。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vector-scalar 运算可以有三种可能的形式。在所有三种形式中，向量寄存器组操作数由 vs2 指定。第二个标量源操作数来自三个备选源之一：</font><ol>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于整数运算，标量可以是 5 位立即数 imm[4:0]，编码在 rs1 字段中。除非另有说明，否则该值符号扩展到 SEW 位。</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于整数运算，可以从 rs1 指定的标量 x 寄存器中获取标量。如果 XLEN&gt;SEW，除非另有说明，否则使用 x 寄存器的</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">最低 SEW 位</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">。</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果 XLEN &lt; SEW, 则要将x寄存器的值有符号扩展到SEW。</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于浮点运算，可以从标量 f 寄存器中获取标量。如果 FLEN &gt; SEW，则检查 f 寄存器中的值是否为有效的 NaN-boxed（[[NaN-Boxing]]）值，在这种情况下</font><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">，使用 f 寄存器的最低有效 SEW 位，否则使用规范的 NaN 值。</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">保留任何浮点向量操作数的 EEW 不是受支持的浮点类型宽度（包括 FLEN &lt; SEW 时）的向量指令。</font></li>
</ol>
</li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 一些指令对 5 位立即数进行零扩展，并通过在汇编语法中命名立即数 uimm 来表示这一点。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当向 Zfinx/Zdinx/Zhinx 扩展添加向量扩展时，浮点标量参数取自 x 寄存器。这些扩展不支持 NaN-boxed，因此向量浮点标量值使用与整数标量操作数相同的规则生成（即，当 XLEN &gt; SEW 使用最低 SEW 位时，当 XLEN &lt; SEW 使用符号扩展值）。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">矢量算术指令在 vm 字段的控制下进行mask操作：</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728541176028-dc73beb6-de58-45fa-ad76-2b4017e941b1.png"></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">在编码中，vs2 是第一个操作数，而 rs1/imm 是第二个操作数。这与标准标量排序相反。这种安排保留了现有的编码约定，即只读取一个标量寄存器的指令，从 rs1 读取它，并且 5 位立即数来自 rs1 字段</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量三元算术指令的汇编语法模式（乘加）：</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728541225079-66865174-b17f-4790-96f2-a7007f1c8e81.png"></li>
<li><strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);"> 对于三元乘加运算，汇编语法总是将目标向量寄存器放在最前面，然后是 rs1 或 vs1，然后是 vs2。这种排序为这些三元运算提供了更自然的汇编程序读取，因为乘法操作数总是彼此相邻</font></li>
</ul>
<p><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Widening-Vector-Arithmetic-Instructions"><a href="#Widening-Vector-Arithmetic-Instructions" class="headerlink" title="Widening Vector Arithmetic Instructions "></a><font style="color:rgb(0,0,0);">Widening Vector Arithmetic Instructions</font><font style="color:#DF2A3F;background-color:rgb(247, 248, 250);"> </font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一些向量算术指令被定义为widening（加宽）操作，其中目标向量寄存器组具有 EEW=2<em>SEW 和 EMUL=2</em>LMUL。这些通常在操作码上被赋予 </font><em><em><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vw</font></em><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 前缀</font></em><em><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，或者为向量浮点指令赋予 </font>**<font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vfw</font></em>**<font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">第一个向量寄存器组操作数可以是单宽或双宽:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728541398448-ca9a164b-ffd1-4a30-9beb-956c0c5bd234.png"></p>
<ul>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 最初，w 后缀用于操作码，但这可能与使用 w 后缀表示双字整数中的字长操作混淆，因此 w 被移至前缀。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 浮点加宽操作已从 vwf* 更改为 vfw<em>，以便与将写入 fw</em> 的任何标量扩展浮点操作更加一致。</font></li>
</ul>
<h3 id="Narrowing-Vector-Arithmetic-Instructions"><a href="#Narrowing-Vector-Arithmetic-Instructions" class="headerlink" title="Narrowing Vector Arithmetic Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Narrowing Vector Arithmetic Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">提供了一些指令来将双宽度源向量转换为单宽度目标向量。这些指令将 EEW/EMUL=2<em>SEW/2</em>LMUL 由 vs2 指定的向量寄存器组转换为具有当前 SEW/LMUL 设置的向量寄存器组。如果有第二个源向量寄存器组（由 vs1 指定），则它与结果的宽度相同（更窄），即vs1的 EEW=SEW。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 另一种设计决策是将 SEW/LMUL 视为定义源向量寄存器组的大小。</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这里的选择是基于这样一种信念，即所选择的方法将需要更少的 vtype 更改。</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意设置掩码寄存器的比较操作也隐含地属于归约操作。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">操作码上的 vn* 前缀用于区分汇编程序中的这些指令，或 vfn* 前缀用于归约的浮点操作码。双宽度源向量寄存器组由源操作数后缀中的 w 表示（例如，vnsra.wv）</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728541698982-1069e08b-d558-47b9-b1d8-256fc34b05e8.png"></li>
</ul>
<h2 id="Vector-Integer-Arithmetic-Instructions"><a href="#Vector-Integer-Arithmetic-Instructions" class="headerlink" title="Vector Integer Arithmetic Instructions"></a><font style="color:rgb(0,0,0);">Vector Integer Arithmetic Instructions</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">提供了一组向量整数算术指令。除非另有说明，否则整数运算会在溢出时wrap（ 相当于不对溢出做特殊处理）。</font></li>
</ul>
<h3 id="Vector-Single-Width-Integer-Add-and-Subtract"><a href="#Vector-Single-Width-Integer-Add-and-Subtract" class="headerlink" title="Vector Single-Width Integer Add and Subtract"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Integer Add and Subtract</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">提供向量整数加减法。还为向量标量形式提供了反向减法指令。<br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728542358324-23ec6964-2d3a-4712-b078-4ec253f5c70b.png"></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">可以使用带有 x0 标量操作数的反向减法指令对整数值向量求反。提供了汇编伪指令 vneg.v vd,vs = vrsub.vx vd,vs,x0。</font></li>
</ul>
<h3 id="Vector-Widening-Integer-Add-x2F-Subtract"><a href="#Vector-Widening-Integer-Add-x2F-Subtract" class="headerlink" title="Vector Widening Integer Add/Subtract "></a><font style="color:rgb(0,0,0);">Vector Widening Integer Add/Subtract</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">加宽 加/减 指令在有符号和无符号变体中都提供，两者的区别在于较窄的源操作数在形成双宽度的和之前是进行符号扩展还是零扩展。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728542651256-4b2ea53e-dca8-4860-ac7d-a7cd6d59496c.png"></p>
<ul>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 使用标量操作数为 x0 的加宽加法指令可以将整数值的宽度加倍。提供汇编伪指令 </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vwcvt</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">.x.x.v vd,vs,vm = </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vwadd</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">.vx vd,vs,x0,vm 和 </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vwcvtu</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">.x.x.v vd,vs,vm = </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vwaddu</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">.vx vd,vs,x0,vm。</font></li>
</ul>
<h3 id="Vector-Integer-Extension"><a href="#Vector-Integer-Extension" class="headerlink" title="Vector Integer Extension"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Integer Extension</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这类指令将零或符号扩展 EEW 小于 SEW 的源向量整数操作数，以填充目标中 SEW 大小的元素。源的 EEW 是 SEW 的 1/2、1/4 或 1/8，而源的 EMUL 是 (EEW/SEW)*LMUL。目的元素的 EEW 等于 SEW，EMUL 等于 LMUL。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728545828188-9b2391d9-e4ee-4d45-af8b-d9a24b71733a.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果源 EEW 不是支持的宽度，或者源 EMUL 低于最小合法 LMUL，则保留指令编码。</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">注意</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> 标准向量加载指令访问与目标寄存器元素大小相同的内存值。一些应用程序代码需要对更宽元素中的一系列操作数宽度进行操作，例如，从内存中加载一个字节并添加到一个八字节元素。为了避免必须提供向量加载指令的数量与数据类型（字节、字、半字以及有符号/无符号变体）的数量的叉积，我们改为添加显式扩展指令，如果合适，可以使用加宽算术指令不可用。</font></li>
</ul>
<h3 id="Vector-Integer-Add-with-Carry-x2F-Subtract-with-Borrow-Instructions"><a href="#Vector-Integer-Add-with-Carry-x2F-Subtract-with-Borrow-Instructions" class="headerlink" title="Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions "></a><font style="color:rgb(0,0,0);">Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">为了支持多字整数运算，提供了对进位操作的指令。对于每个操作（加法或减法），提供两条指令：</font><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一条是提供结果（SEW宽度）</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">另一条是产生进位输出（编码为一个mask布尔值）。</font></li>
</ul>
</li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">进位输入和输出使用掩码寄存器来表示，由于编码限制，进位输入必须来自隐式的</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">v0</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">寄存器，但是进位输出可以写到任何遵循源/目的重叠限制的向量寄存器。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vadc和vsbc对源操作数和进位或借位进行加减，并将结果写入向量寄存器vd。这些指令被编码为带mask的指令（vm=0），但是它们对所有的主体元素进行操作并写回。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmadc和vmsbc对源操作数进行加减运算，如果是包含mask的指令形式(vm=0)，则还会加上进位或减去借位，并将进位结果写回vd的mask寄存器。如果没有包含mask形式（vm=1），则没有进位或借入。这些指令对所有的主体元素进行操作和回写，即使是被masked的。因为这些指令产生了一个mask值，所以它们总是以tail-agnostic，即尾部不可知的策略进行操作。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728546733726-209a35ee-d81f-47f9-b362-93a69cd111e6.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一条带进位传播的加减法需要两条使用相同输入的指令：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728546917178-e4a5ee63-0e5a-4b6d-8086-65b071f36a62.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">下面是带借位的向量减法，向量减法没有减立即数的指令：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728546944255-61324caa-94b7-4c6e-ac1e-3875ff08ceb9.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于vmsbc，如果截断前的差值为负数，则借位被定义为1。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于vadc和vsbc，如果目的向量寄存器是v0，指令编码被保留。</font></li>
</ul>
<h3 id="Vector-Bitwise-Logical-Instructions"><a href="#Vector-Bitwise-Logical-Instructions" class="headerlink" title="Vector Bitwise Logical Instructions"></a><font style="color:rgb(0,0,0);">Vector Bitwise Logical Instructions</font></h3><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728547092186-a9f9a085-0d13-46dd-b3ab-13a025f0f0c8.png"></p>
<h3 id="Vector-Single-Width-Shift-Instructions"><a href="#Vector-Single-Width-Shift-Instructions" class="headerlink" title="Vector Single-Width Shift Instructions"></a><font style="color:rgb(0,0,0);">Vector Single-Width Shift Instructions</font></h3><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728547167173-6c3ae9f5-c621-47db-bb0a-94366e67e2ca.png"></p>
<h3 id="Vector-Narrowing-Integer-Right-Shift-Instructions"><a href="#Vector-Narrowing-Integer-Right-Shift-Instructions" class="headerlink" title="Vector Narrowing Integer Right Shift Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Narrowing Integer Right Shift Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728547277949-e4797bf2-743b-44c2-b1ee-69af47084204.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">使用标量操作数为x0的缩小整数移位指令，一个整数值的宽度可以减半。提供了一个汇编伪指令 </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vncvt</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">.x.x.w vd,vs,vm = </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vnsrl</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">.wx vd,vs,x0,vm。</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Vector-Integer-Compare-Instructions"><a href="#Vector-Integer-Compare-Instructions" class="headerlink" title="Vector Integer Compare Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Integer Compare Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">以下的整数比较指令，如果比较结果为真，则将1写入目的掩码寄存器元素。目的屏蔽向量总是保存在一个单一的向量寄存器中，目标屏蔽向量寄存器可以与源向量屏蔽寄存器(v0)相同。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728547605247-9783b4d4-b673-4af4-8e11-efc05c633127.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">不提供vmslt{u}.vi的即时形式，因为即时值可以减少1，并使用vmsle{u}.vi的变体来代替。vmsle.vi的范围是-16到15，导致vmslt.vi的有效范围是-15到16。vmsleu.vi的范围是0到15，导致有效的vmsltu.vi范围是1到16（注意，vmsltu.vi的即时0没有用，因为它总是假的）。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">因为5位向量的即时值总是带符号的，当simm5即时值的高位被设置时，vmsleu.vi也支持2</font><sup><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">SEW-16到2</font></sup><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">SEW-1范围内的无符号即时值，允许相应的vmsltu.vi对2</font><sup><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">SEW-15到2</font></sup><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">SEW范围内的无符号即时值进行比较。注意，带有2SEW即时值的vmsltu.vi是没有用的，因为它始终是真的。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728547749883-efbc51f6-1374-4202-9f71-1194048cac53.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">同样，没有提供vmsge{u}.vi，比较是用vmsgt{u}.vi实现的，即时值减一。由此产生的有效vmsge.vi范围是-15到16，由此产生的有效vmsgeu.vi范围是1到16（注意，立即为0的vmsgeu.vi没有用，因为它总是真的）。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">寄存器标量和即时值的vmsgt形式的提供是为了让一条比较指令提供正确的mask值的极性，而不需要使用额外的屏蔽逻辑指令。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">为了减少编码空间，没有直接提供vmsge{u}.vx形式，因此va≥x的情况需要特殊处理。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmsge{u}.vx操作可以通过将x的值减少1并使用vmsgt{u}.vx指令来合成，前提是这样做不会使x中的表示值溢出：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728548000701-453e6aaf-01b4-4615-944b-a42ce7f677c3.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">上述序列通常是最有效的实现，但在x的范围未知的情况下，可以提供汇编伪指令（&gt;=可以通过小于的结果取反得到）：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728548029911-feac6acf-d078-4d1a-8d8d-0cd469403b34.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">可以利用v0来快速地实现比较表达式的相与操作：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728548050379-a805d9b0-c9ee-420f-9278-feeada7b037d.png"></p>
<h3 id="Vector-Integer-Min-x2F-Max-Instructions"><a href="#Vector-Integer-Min-x2F-Max-Instructions" class="headerlink" title="Vector Integer Min/Max Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Integer Min/Max Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持有符号和无符号整数的最小和最大指令。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728612974292-37e2368f-a623-4c38-bab5-65c5e819c6cd.png"></p>
<h3 id="Vector-Single-Width-Integer-Multiply-Instructions"><a href="#Vector-Single-Width-Integer-Multiply-Instructions" class="headerlink" title="Vector Single-Width Integer Multiply Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Integer Multiply Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">单宽乘法指令执行SEW位<em>SEW位的乘法，产生2</em>SEW位的乘积，然后在SEW位宽的目的寄存器中返回乘积的一半。mul版本将乘积的低字写到目标寄存器，而mulh版本将乘积的高字写到目标寄存器。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728613048174-429fdd99-e687-4542-af6e-404d0c46df59.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<h3 id="Vector-Integer-Divide-Instructions"><a href="#Vector-Integer-Divide-Instructions" class="headerlink" title="Vector Integer Divide Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Integer Divide Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">除法和余数指令等同于RISC-V标准标量整数乘法<br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728613547366-7ecba156-31f1-4efa-b250-8eb8a4cb5b8a.png"></li>
</ul>
<h3 id="Vector-Widening-Integer-Multiply-Instructions"><a href="#Vector-Widening-Integer-Multiply-Instructions" class="headerlink" title="Vector Widening Integer Multiply Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Widening Integer Multiply Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">加宽的整数乘法指令从SEW位<em>SEW位的乘法中返回完整的2</em>SEW位乘积。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728613591715-2774cbbc-829e-4b92-a148-c128fca032f4.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<h3 id="Vector-Single-Width-Integer-Multiply-Add-Instructions"><a href="#Vector-Single-Width-Integer-Multiply-Add-Instructions" class="headerlink" title="Vector Single-Width Integer Multiply-Add Instructions"></a><font style="color:rgb(0,0,0);">Vector Single-Width Integer Multiply-Add Instructions</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></h3>
<font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">整数乘加指令是具有破坏性的（会修改源操作寄存器的值），有两种形式，一种是覆盖加数或减数（vmacc, vnmsac），一种是覆盖第一个乘数（vmadd, vnmsub）</font>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728613677684-4dec0e50-d2ce-421a-aaaf-11276ee8a04e.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">乘积的低半部分与第三个操作数相加或相减。</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Vector-Widening-Integer-Multiply-Add-Instructions"><a href="#Vector-Widening-Integer-Multiply-Add-Instructions" class="headerlink" title="Vector Widening Integer Multiply-Add Instructions "></a><font style="color:rgb(0,0,0);">Vector Widening Integer Multiply-Add Instructions</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">加宽的整数乘加指令将SEW-位<em>SEW-位乘法的全部2</em>SEW-位乘积加到2<em>SEW-位值，并产生2</em>SEW-位结果。支持有符号和无符号乘法操作数的所有组合。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728613960612-95ff12e1-c13b-4a75-8374-e75ab6e39fba.png"></p>
<h3 id="Vector-Integer-Merge-Instructions"><a href="#Vector-Integer-Merge-Instructions" class="headerlink" title="Vector Integer Merge Instructions"></a><font style="color:rgb(0,0,0);">Vector Integer Merge Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">矢量整数合并指令根据一个mask合并两个源操作数。与普通的算术指令不同，合并指令对所有的主体元素（即从vstart到vl中的当前矢量长度的元素集）进行操作。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmerge指令被编码为带mask的指令（vm=0）。该指令将两个来源结合起来，具体如下：在mask值为0时，第一个操作数被复制到目的元素上，否则第二个操作数被复制到目的元素上。第一个操作数总是一个由vs2指定的向量寄存器组。第二个操作数是由vs1指定的向量寄存器组或由rs1指定的标量x寄存器或一个5位符号扩展的立即数：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614020473-ddea89c2-7dab-4ccd-a0ec-e7eaf806767e.png"></p>
<h3 id="Vector-Integer-Move-Instructions"><a href="#Vector-Integer-Move-Instructions" class="headerlink" title="Vector Integer Move Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Integer Move Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">矢量整数移动指令复制一个源操作数到一个矢量寄存器组。vmv.v.v变体复制了一个向量寄存器组，而vmv.v.x和vmv.v.i变体将一个标量寄存器或立即数复制到目标向量寄存器组的所有有效元素。这些指令被编码为无mask指令（vm=1）。第一个操作数（vs2）必须包含v0，vs2中的任何其他矢量寄存器编号都是保留的。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">mask可以用一个序列vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0来拓宽成SEW宽度的元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">矢量整数移动指令</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">与矢量合并指令共享编码</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">，但移动指令的vm=1，vs2=v0。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmv.v.v vd, vd的形式，使主体元素保持不变，可以用来表示寄存器的下一次使用将是EEW等于SEW。</font><br><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614052022-2e739406-b20f-43c3-abed-2cd4504585d1.png"></li>
</ul>
<h2 id="Vector-Fixed-Point-Arithmetic-Instructions"><a href="#Vector-Fixed-Point-Arithmetic-Instructions" class="headerlink" title="Vector Fixed-Point Arithmetic Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Fixed-Point Arithmetic Instructions</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">将整数运算指令扩展即可支持定点运算指令</font></li>
</ul>
<h3 id="Vector-Single-Width-Saturating-Add-and-Subtract"><a href="#Vector-Single-Width-Saturating-Add-and-Subtract" class="headerlink" title="Vector Single-Width Saturating Add and Subtract"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Saturating Add and Subtract</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614166979-cff55f97-1086-49a6-b22b-e5efc81c77e2.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">与整数加减的区别是多了s 标记,表示saturate</font></li>
</ul>
<h3 id="Vector-Single-Width-Averaging-Add-and-Subtract"><a href="#Vector-Single-Width-Averaging-Add-and-Subtract" class="headerlink" title="Vector Single-Width Averaging Add and Subtract"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Averaging Add and Subtract</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">均值加法和均值减法会将加法或者减法的结果右移一位并根据vxrm的设置进行舍入</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614200562-a0991fe8-a34b-4faf-a710-92eb976c7a1b.png"></p>
<h3 id="Vector-Single-Width-Fractional-Multiply-with-Rounding-and-Saturation"><a href="#Vector-Single-Width-Fractional-Multiply-with-Rounding-and-Saturation" class="headerlink" title="Vector Single-Width Fractional Multiply with Rounding and Saturation"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Fractional Multiply with Rounding and Saturation</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">有符号分数乘法指令计算两个SEW位的输入, 输出2*SEW位宽的输出,然后将结果右移SEW-1位,这些右移的位据vxrm舍入,之后进行饱和截位到SEW位。如果结果导致饱和,则需要设置vxsat位。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614657763-d8440422-4f91-460f-86e9-a372262c2daf.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Vector-Single-Width-Scaling-Shift-Instructions"><a href="#Vector-Single-Width-Scaling-Shift-Instructions" class="headerlink" title="Vector Single-Width Scaling Shift Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Scaling Shift Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这些指令将右移输入,根据vxrm将右移的位进行舍入。右移填充的位可以无符号扩展(vssrl)也可以有符号扩展sign-extending (vssra)。vs2是需要移位的寄存器组, vs1是移位量寄存器组,标量整数寄存器rs1或zero-extended的5bit立即数也可以用来作为移位量。对于移位量, 只有低log2(SEW) bit是有效的。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614724825-a02ddd03-7b2e-4680-8a9c-b8ddee7a5fb9.png"></p>
<h3 id="Vector-Narrowing-Fixed-Point-Clip-Instructions"><a href="#Vector-Narrowing-Fixed-Point-Clip-Instructions" class="headerlink" title="Vector Narrowing Fixed-Point Clip Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Narrowing Fixed-Point Clip Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vnclip指令用于将一个定点数归约到一个目的向量中. 该指令支持rounding, scaling和饱和.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vs2指定了源数据, vs1指定了scale的shift amount</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614768858-64c2fdd3-3a84-475c-89f6-256a37771657.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">具体的round模式由vxrm CSR寄存器指定. round在目的寄存器的低位进行, 先于饱和操作</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果目的元素存在饱和的情况, 则vxsat的对应bit会拉高.</font></li>
</ul>
<h2 id="Vector-Floating-Point-Instructions"><a href="#Vector-Floating-Point-Instructions" class="headerlink" title="Vector Floating-Point Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Instructions</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">目前支持32和64bit的满足IEEE-754/2008标准的floating-point</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果浮点单元状态位mstatus.FS被关闭了, 则任意执行向量浮点指令的尝试都会抛出指令异常. 同理, 任意改变了浮点状态寄存器的向量浮点指令都需要将mstatus.FS设置为dirty</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果实现了hypervisor扩展且V=1, 则vsstatus.FS位也需要考虑进来, 即mstatus.FS或vsstatus.FS位被关闭, 则任意执行向量浮点指令的尝试都会抛出指令异常. 同理, 任意改变了浮点状态寄存器的向量浮点指令都需要将mstatus.FS和vsstatus.FS设置为dirty</font></li>
</ul>
<h3 id="Vector-Floating-Point-Exception-Flags"><a href="#Vector-Floating-Point-Exception-Flags" class="headerlink" title="Vector Floating-Point Exception Flags"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Exception Flags</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">向量中活跃的浮点元素会设置标准FP扩展标记位: fflags.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">非活跃的元素不会修改fflags对应位</font></li>
</ul>
<h3 id="Vector-Single-Width-Floating-Point-Add-x2F-Subtract-Instructions"><a href="#Vector-Single-Width-Floating-Point-Add-x2F-Subtract-Instructions" class="headerlink" title="Vector Single-Width Floating-Point Add/Subtract Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Floating-Point Add/Subtract Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614917527-3483c2f0-74e3-4656-bd6f-5a5134a73edd.png"></p>
<h3 id="Vector-Widening-Floating-Point-Add-x2F-Subtract-Instructions"><a href="#Vector-Widening-Floating-Point-Add-x2F-Subtract-Instructions" class="headerlink" title="Vector Widening Floating-Point Add/Subtract Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Widening Floating-Point Add/Subtract Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728614987711-467c76aa-fe2b-4cd7-88c8-3ca496653ecd.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></p>
<h3 id="Vector-Single-Width-Floating-Point-Multiply-x2F-Divide-Instructions"><a href="#Vector-Single-Width-Floating-Point-Multiply-x2F-Divide-Instructions" class="headerlink" title="Vector Single-Width Floating-Point Multiply/Divide Instructions"></a><font style="color:rgb(0,0,0);">Vector Single-Width Floating-Point Multiply/Divide Instructions</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></h3><p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728615220183-76ef061d-a5a9-49e2-98d8-826b0e23a1ce.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<h3 id="Vector-Widening-Floating-Point-Multiply"><a href="#Vector-Widening-Floating-Point-Multiply" class="headerlink" title="Vector Widening Floating-Point Multiply"></a><font style="color:rgb(0,0,0);">Vector Widening Floating-Point Multiply</font></h3><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728615245093-5974e7f8-0d97-4b68-8fce-527c9d4aca8c.png"></p>
<h3 id="Vector-Single-Width-Floating-Point-Fused-Multiply-Add-Instructions"><a href="#Vector-Single-Width-Floating-Point-Fused-Multiply-Add-Instructions" class="headerlink" title="Vector Single-Width Floating-Point Fused Multiply-Add Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Floating-Point Fused Multiply-Add Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728615606432-2b5b08bd-9ff0-4f83-8a45-4e69f1ae5e18.png"></p>
<h3 id="Vector-Widening-Floating-Point-Fused-Multiply-Add-Instructions"><a href="#Vector-Widening-Floating-Point-Fused-Multiply-Add-Instructions" class="headerlink" title="Vector Widening Floating-Point Fused Multiply-Add Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Widening Floating-Point Fused Multiply-Add Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728626357975-3aa56d53-9428-4d07-a32a-87a6e86c9f6d.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<h3 id="Vector-Floating-Point-Square-Root-Instruction"><a href="#Vector-Floating-Point-Square-Root-Instruction" class="headerlink" title="Vector Floating-Point Square-Root Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Square-Root Instruction</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728625182031-e9d2baad-dfee-4c5c-b068-951e04524efb.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></p>
<h3 id="Vector-Floating-Point-Reciprocal-Square-Root-Estimate-Instruction"><a href="#Vector-Floating-Point-Reciprocal-Square-Root-Estimate-Instruction" class="headerlink" title="Vector Floating-Point Reciprocal Square-Root Estimate Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Reciprocal Square-Root Estimate Instruction</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728625642495-c976eadd-22ab-4a65-9b50-ec4c67e39a20.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令返回1/sqrt(x)结果的7bit估计值</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">下表给出了该指令的输出情况:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728625668864-de2018b0-1da1-49c9-b45c-3814c9cf90e9.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">sqrt是采用查找表实现的.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">规格化后的浮点数的exp的0bit和significand的高6bit(不包括最高位的1)将组合起来寻址下面的查找表. 查找表的输出为结果的significand的高7位(不包括最高位的1)</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728626373792-c5c9f44b-fd41-4b98-8a43-38a8a4e7c37d.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728626515352-a8bfccfc-4797-4a0a-b6b0-c2da4b33cd99.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728626526215-526b34e0-ff0a-4359-babf-7873c7fdd0ce.png"></p>
<h3 id="Vector-Floating-Point-Reciprocal-Estimate-Instruction"><a href="#Vector-Floating-Point-Reciprocal-Estimate-Instruction" class="headerlink" title="Vector Floating-Point Reciprocal Estimate Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Reciprocal Estimate Instruction</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">返回1/x的7bit估计值:<br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728626652000-d36a3020-0bf0-4c1d-a639-8dab25e72952.png"></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">下表是所有可能的输出值:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728626667556-307e3545-0000-4cea-b792-8d2bc18f21b0.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">significand的高7bit(不包括最开始的1)索引查找表, 获得7bit的输出值:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728627353690-e515d9f5-5797-4a76-9818-5887dfa5ab26.png"><br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728627367898-a01f5ec5-6ec6-4706-a378-c6c1bba8d0c0.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728627378156-e07086ee-fe75-466c-834e-1af1faaa30df.png"></p>
<h3 id="Vector-Floating-Point-MIN-x2F-MAX-Instructions"><a href="#Vector-Floating-Point-MIN-x2F-MAX-Instructions" class="headerlink" title="Vector Floating-Point MIN/MAX Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point MIN/MAX Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728627408038-2b7b728e-cb24-407d-84b1-3bf8454a0192.png"></p>
<h3 id="Vector-Floating-Point-Sign-Injection-Instructions"><a href="#Vector-Floating-Point-Sign-Injection-Instructions" class="headerlink" title="Vector Floating-Point Sign-Injection Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Sign-Injection Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728627425178-fa51a221-770b-46da-9ac3-1b7a3d7724cf.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令可以将vs1的符号与vs2的非符号部分进行组合</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">可以实现取相反数:vfneg.v vd,vs = vfsgnjn.vv vd,vs,vs.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">可以实现取绝对值: vfabs.v vd,vs = vfsgnjx.vv vd,vs,vs.</font></li>
</ul>
<h3 id="Vector-Floating-Point-Compare-Instructions"><a href="#Vector-Floating-Point-Compare-Instructions" class="headerlink" title="Vector Floating-Point Compare Instructions "></a><font style="color:rgb(0,0,0);">Vector Floating-Point Compare Instructions</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728627465322-ca2f0803-e566-4076-bb0a-48ddbcd5edff.png"></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728627661327-b6a8b1c0-fde6-4ffe-89cf-aace616a7809.png"></p>
<h3 id="Vector-Floating-Point-Classify-Instruction"><a href="#Vector-Floating-Point-Classify-Instruction" class="headerlink" title="Vector Floating-Point Classify Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Classify Instruction</font></h3><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728628299955-29ef95f7-aa24-49fd-a35f-81cc91d4c86b.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令与标量classify操作相同</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">产生的10bit mask只占用结果元素的低位, 高SEW-10位为0</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令只对SEW=16b以上的位宽有效</font></li>
</ul>
<font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">  
</font>

<h3 id="Vector-Floating-Point-Merge-Instruction"><a href="#Vector-Floating-Point-Merge-Instruction" class="headerlink" title="Vector Floating-Point Merge Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Merge Instruction</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728628358790-1bf04282-69c8-49bf-964b-d2f2a3a99015.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">是一条masked指令, 根据mask选择数据</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Vector-Floating-Point-Move-Instruction"><a href="#Vector-Floating-Point-Move-Instruction" class="headerlink" title="Vector Floating-Point Move Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Floating-Point Move Instruction</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728628496933-b9ffc216-011c-4c61-a89b-fffb992c7f96.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">将rs1对应的浮点数拷贝到vd</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令等同于: vfmerge.vfm, but with vm=1 and vs2=v0.</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Single-Width-Floating-Point-x2F-Integer-Type-Convert-Instructions"><a href="#Single-Width-Floating-Point-x2F-Integer-Type-Convert-Instructions" class="headerlink" title="Single-Width Floating-Point/Integer Type-Convert Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Single-Width Floating-Point/Integer Type-Convert Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">将SEW宽度的浮点数转换成同宽度的整数(或者反过来)</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728628612014-a7127a54-2682-4635-be8a-59dbd3f9c4c5.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">转换时根据frm寄存器动态rounding</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Widening-Floating-Point-x2F-Integer-Type-Convert-Instructions"><a href="#Widening-Floating-Point-x2F-Integer-Type-Convert-Instructions" class="headerlink" title="Widening Floating-Point/Integer Type-Convert Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Widening Floating-Point/Integer Type-Convert Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728628667923-e817563f-a738-4f6c-a6df-109db9777c36.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">双宽度向单宽度的浮点-整数转换</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Narrowing-Floating-Point-x2F-Integer-Type-Convert-Instructions"><a href="#Narrowing-Floating-Point-x2F-Integer-Type-Convert-Instructions" class="headerlink" title="Narrowing Floating-Point/Integer Type-Convert Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Narrowing Floating-Point/Integer Type-Convert Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728629182576-4316f691-a2f0-4056-98e4-82d834a113f7.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">双宽度向单宽度的浮点-整数转换</font></li>
</ul>
<h2 id="Vector-Reduction-Operations"><a href="#Vector-Reduction-Operations" class="headerlink" title="Vector Reduction Operations"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Reduction Operations</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">归约指令接收一个向量寄存器组的元素,和一个放在向量寄存器元素0位置的标量, 通过某种归约操作得到一个标量值, 该标量值也放在一个向量寄存器的元素0位置.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">归约操作中的标量都是放在一个向量寄存器中, 而不是寄存器组.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">之所以不把结果放在标量寄存器, 是为了与标量core 去耦</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">源向量寄存器组中的非活跃元素将不参与归约操作.</font></li>
<li><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">目的向量寄存器中, 除了元素0的部分都是tail</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">, 遵循当前的尾部不可知或不变(tail agnostic/undisturbed)的原则.</font></li>
</ul>
<h3 id="Vector-Single-Width-Integer-Reduction-Instructions"><a href="#Vector-Single-Width-Integer-Reduction-Instructions" class="headerlink" title="Vector Single-Width Integer Reduction Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Integer Reduction Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728630313047-fe28d47d-56d0-4e60-a6ca-8e3432857888.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">溢出时, wrap around</font></li>
</ul>
<p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></p>
<h3 id="Vector-Widening-Integer-Reduction-Instructions"><a href="#Vector-Widening-Integer-Reduction-Instructions" class="headerlink" title="Vector Widening Integer Reduction Instructions"></a><font style="color:rgb(0,0,0);">Vector Widening Integer Reduction Instructions</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font></h3><p><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在归约操作之前对向量元素位宽进行扩展, 从SEW-2*SEW</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">溢出时, wrap around</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728630417874-cd1593bf-0b74-4439-9de9-9265ece98f33.png"></p>
<h3 id="Vector-Single-Width-Floating-Point-Reduction-Instructions"><a href="#Vector-Single-Width-Floating-Point-Reduction-Instructions" class="headerlink" title="Vector Single-Width Floating-Point Reduction Instructions"></a><font style="color:rgb(0,0,0);">Vector Single-Width Floating-Point Reduction Instructions</font></h3><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728633874066-d6855215-733f-4474-b5c7-f3f59a54b2c1.png"></p>
<h4 id="Vector-Ordered-Single-Width-Floating-Point-Sum-Reduction"><a href="#Vector-Ordered-Single-Width-Floating-Point-Sum-Reduction" class="headerlink" title="Vector Ordered Single-Width Floating-Point Sum Reduction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Ordered Single-Width Floating-Point Sum Reduction</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">ordered的指令必须按顺序对元素进行归约:<br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728634010613-8832c2c8-114f-4a1b-8af3-3c22485770f4.png"></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">非活跃的元素不参与</font></li>
</ul>
<h4 id="Vector-Unordered-Single-Width-Floating-Point-Sum-Reduction"><a href="#Vector-Unordered-Single-Width-Floating-Point-Sum-Reduction" class="headerlink" title="Vector Unordered Single-Width Floating-Point Sum Reduction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Unordered Single-Width Floating-Point Sum Reduction</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">指令汇编:</font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vfredusum</font></strong></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">无序指令需要实现与归约树等价的计算过程</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">每个节点接受两个操作数生成一个结果, 在计算时, 每个节点都是精确的(浮点的指数和小数部分都有无限精度), 得到精确的浮点结果后再规格化为SEW位的标准浮点数</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">每个节点的浮点数范围和精度可能都不同</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">实现时可以给最后的结果加上一个加法标志</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当向下舍入（接近-∞）时，加法标识为0.0，或者对于所有其他舍入模式，加法标识为-0.0。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">对于vtype和vl中的给定值，归约树结构必须是确定的。</font></li>
</ul>
<h4 id="Vector-Single-Width-Floating-Point-Max-and-Min-Reductions"><a href="#Vector-Single-Width-Floating-Point-Max-and-Min-Reductions" class="headerlink" title="Vector Single-Width Floating-Point Max and Min Reductions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Single-Width Floating-Point Max and Min Reductions</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">浮点最大最小归约指令无论操作的顺序如何, 都应该返回相同的结果和相同的异常</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果没有活跃元素, 则vs1[0]会被复制到目的寄存器, 不会规格化NaN值, 也不会设置异常标志</font></li>
</ul>
<h3 id="Vector-Widening-Floating-Point-Reduction-Instructions"><a href="#Vector-Widening-Floating-Point-Reduction-Instructions" class="headerlink" title="Vector Widening Floating-Point Reduction Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Widening Floating-Point Reduction Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">加宽的归约指令, vs2在进入归约操作时会加宽到2*SEW 位<br></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"> </font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728636151374-e3015653-fd9e-4b79-95c8-96f5b0a896d1.png"></li>
</ul>
<h2 id="Vector-Mask-Instructions"><a href="#Vector-Mask-Instructions" class="headerlink" title="Vector Mask Instructions"></a><font style="color:rgb(0,0,0);">Vector Mask Instructions</font></h2><h3 id="Vector-Mask-Register-Logical-Instructions"><a href="#Vector-Mask-Register-Logical-Instructions" class="headerlink" title="Vector Mask-Register Logical Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Mask-Register Logical Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这类指令是针对单个向量寄存器的(不是组), 因此会忽略vlmul的值</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">索引小于vstart的元素将保持不变. 执行指令后vstart会复位为0</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">mask logical指令都是unmasked的, 所以不存在非活跃元素, 并且总是遵循尾部不可知原则</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728637566784-cc3b7457-32d3-4e69-aab8-ba08ab49f3d8.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一些伪指令:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728637672417-93f1947b-554d-467a-bacf-d438c2eca96d.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">上述8种逻辑操作可以产生16种任意的逻辑操作:</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728637691058-0d5b47ce-6e53-4993-9355-45fdb6a19aeb.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728637699456-4522bd0e-1840-4554-948e-54b30e99370e.png"></p>
<h3 id="Vector-count-population-in-mask-vcpop-m"><a href="#Vector-count-population-in-mask-vcpop-m" class="headerlink" title="Vector count population in mask vcpop.m"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector count population in mask vcpop.m</font></h3><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1728638091941-abe4cbc8-1171-4aec-988d-1a4928c2f2f5.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令的源操作数vs2是一个包含mask值的响亮寄存器</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">popcount, 该指令对vs2中活跃元素进行计数</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">可以在一个mask的指导下进行:</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071022624-f22a6f2f-7a0b-42ae-b318-c93f30a78f13.png"></li>
</ul>
<h3 id="vfirst-find-first-set-mask-bit"><a href="#vfirst-find-first-set-mask-bit" class="headerlink" title="vfirst find-first-set mask bit"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vfirst find-first-set mask bit</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071039369-b0821406-cb11-4913-b775-34c53046fcff.png">  </p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">找到作为source mask的vs2中活跃元素的首个1， 并将其索引写入通用寄存器GPR。 如果vs2没有活跃元素， 写入-1到GPR</font></li>
</ul>
<h3 id="vmsbf-m-set-before-first-mask-bit"><a href="#vmsbf-m-set-before-first-mask-bit" class="headerlink" title="vmsbf.m set-before-first mask bit"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmsbf.m set-before-first mask bit</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071057168-7a0e6f0e-f35c-41a6-8478-933f289931d1.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmsbf.m指令接收一个mask向量寄存器作为输入， 将结果写入另一个向量寄存器</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">规则是： 首先将目的向量的所有元素写为1； 之后看源向量， 源向量的第一个为1的活跃元素的位置及其之后将目的向量元素都写成0</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">类似于leading one det</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">目的寄存器不能与源寄存器重合， 如果使用mask（vm=0）, 目的寄存器也不能与v0重合。</font></li>
</ul>
<h3 id="vmsif-m-set-including-first-mask-bit"><a href="#vmsif-m-set-including-first-mask-bit" class="headerlink" title="vmsif.m set-including-first mask bit"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmsif.m set-including-first mask bit</font></h3>

<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">与set-before-first 类似， 区别是第一个1的位置也要置1.</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071085915-9d247823-abde-42c7-b3d1-9a2c16580bd6.png"></li>
</ul>
<h3 id="vmsof-m-set-only-first-mask-bit"><a href="#vmsof-m-set-only-first-mask-bit" class="headerlink" title="vmsof.m set-only-first mask bit"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmsof.m set-only-first mask bit</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">与set-before-first 类似， 区别是只有第一个1的位置要置1.</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071107050-1a0a0816-b6f4-4461-adb7-e3ece9877d98.png"></p>
<h3 id="Example-using-vector-mask-instructions"><a href="#Example-using-vector-mask-instructions" class="headerlink" title="Example using vector mask instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Example using vector mask instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">下面是一个data-dependent exit loop向量化的例子：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071123808-8438c523-0fb5-4f9f-9f5d-4d39be55a047.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071128997-c32c561e-f1ed-4014-b030-b128dcba6a5c.png"></p>
<h3 id="Vector-Iota-Instruction"><a href="#Vector-Iota-Instruction" class="headerlink" title="Vector Iota Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"></font><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Iota Instruction</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">viota.m 指令读取源向量mask寄存器， 并向目的寄存器中依次写入元素。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">写入的规则是： 索引值小于该元素的所有元素之和</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071149339-8b9be780-2951-4362-a7f1-743e008308cf.png"><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);"><br></font></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">viota.m指令可以与memory scatter指令组合以实现向量压缩方法：</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071161190-2f5e8227-9717-467e-8e1b-eadf957bd703.png"></li>
</ul>
<h3 id="Vector-Element-Index-Instruction"><a href="#Vector-Element-Index-Instruction" class="headerlink" title="Vector Element Index Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Element Index Instruction</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">将每个元素的index写到目的寄存器组</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071186554-d8ce90a6-1a6c-40ba-ba08-75b6a32f10af.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vid.v可以用viota.m实现</font></li>
</ul>
<h2 id="Vector-Permutation-Instructions"><a href="#Vector-Permutation-Instructions" class="headerlink" title="Vector Permutation Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Vector Permutation Instructions</font></h2><h3 id="16-1-Integer-Scalar-Move-Instructions"><a href="#16-1-Integer-Scalar-Move-Instructions" class="headerlink" title="16.1. Integer Scalar Move Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.1. Integer Scalar Move Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令向vs2寄存器的第0个元素传入一个标量值</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071207786-69f38877-6456-4674-ac72-d2042663a0fa.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">如果SEW&gt;XLEN, 则只传输XLEN bit， SEW-XLEN个高位将被忽略；如果SEW&lt; XLEN，则将有符号扩展到XLEN位</font></li>
</ul>
<h3 id="16-2-Floating-Point-Scalar-Move-Instructions"><a href="#16-2-Floating-Point-Scalar-Move-Instructions" class="headerlink" title="16.2. Floating-Point Scalar Move Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.2. Floating-Point Scalar Move Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">与上一条指令类似， 只是换成了浮点寄存器：</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071207803-78cca748-2636-4bd5-b9a1-8e275b297811.png"></li>
</ul>
<h3 id="16-3-Vector-Slide-Instructions"><a href="#16-3-Vector-Slide-Instructions" class="headerlink" title="16.3. Vector Slide Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.3. Vector Slide Instructions</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">slide操作比寄存器聚集指令更高效（gather)</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">2的幂次的slide会比较快</font></li>
</ul>
<h4 id="16-3-1-Vector-Slideup-Instructions"><a href="#16-3-1-Vector-Slideup-Instructions" class="headerlink" title="16.3.1. Vector Slideup Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.3.1. Vector Slideup Instructions</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208007-2ed91094-1b71-4770-8741-1b53244f9952.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">offset可以由rs1指定， 也可以由立即数产生</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">从offset到vl的元素会被覆盖：</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208033-2aed0e34-8fc9-4d85-a71e-daf11580a00b.png"></li>
</ul>
<h4 id="16-3-2-Vector-Slidedown-Instructions"><a href="#16-3-2-Vector-Slidedown-Instructions" class="headerlink" title="16.3.2. Vector Slidedown Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.3.2. Vector Slidedown Instructions</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208029-1a2e8992-a162-4cdd-a758-941a581d5a6e.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208299-beed2dd1-f06c-4f8d-b8d7-107643b6076b.png"></p>
<h4 id="16-3-3-Vector-Slide1up"><a href="#16-3-3-Vector-Slide1up" class="headerlink" title="16.3.3. Vector Slide1up"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.3.3. Vector Slide1up</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208396-f6a31dad-b227-408c-877c-0050dbbc33fe.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208662-9fe5377a-4220-401b-a677-99a5252f2560.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令要求目的向量寄存器组不能和源向量寄存器组有交叠</font></li>
</ul>
<h4 id="16-3-4-Vector-Slide1down-Instruction"><a href="#16-3-4-Vector-Slide1down-Instruction" class="headerlink" title="16.3.4. Vector Slide1down Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.3.4. Vector Slide1down Instruction</font></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208677-33458820-449e-4461-a0ba-c6c41968c89a.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071208944-280a1a73-8028-4c92-9889-bb2325bc18e5.png"></p>
<h3 id="16-4-Vector-Register-Gather-Instructions"><a href="#16-4-Vector-Register-Gather-Instructions" class="headerlink" title="16.4. Vector Register Gather Instructions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.4. Vector Register Gather Instructions</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071209204-db660753-35e6-418e-9fa0-bef9fe27958a.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vrgatherei16.vv form uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1.</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">当SEW=8时，每个vs1的元素只能索引256个数据。可能是不够的。所以增加了vrgatherei16指令，使用EEW=16, 可以索引64K的元素。另外，当SEW&gt;16时，可能也是浪费的（没有那么多向量元素来给你索引），此时使用EEW=16也节省了向量寄存器空间</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持标量和立即数形式的gather指令：</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071209222-5490fdfc-e592-4845-8775-14320219feaf.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">此时只会从源寄存器读出一个元素</font></li>
</ul>
<h3 id="16-5-Vector-Compress-Instruction"><a href="#16-5-Vector-Compress-Instruction" class="headerlink" title="16.5. Vector Compress Instruction"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.5. Vector Compress Instruction</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vs1是一个mask寄存器，可以使用vs1中=1的部分选择vs2的元素连续地放入vd</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vd中余下的元素遵循尾部不可知原则。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071209550-d434b30c-3223-433c-9653-6c2a8eb0c876.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071209474-98d40d99-77c0-470e-b204-7180184178ce.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vstart=0时， 该指令会上报陷入。vstart不为0时， 该指令会出发非法指令异常</font></li>
</ul>
<h4 id="16-5-1-Synthesizing-vdecompress"><a href="#16-5-1-Synthesizing-vdecompress" class="headerlink" title="16.5.1. Synthesizing vdecompress"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.5.1. Synthesizing vdecompress</font></h4><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">该指令将一个压缩的向量按照mask还原</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071209740-10bc93bc-f68f-460c-ab35-65aef9b61fa6.png"></p>
<h3 id="16-6-Whole-Vector-Register-Move"><a href="#16-6-Whole-Vector-Register-Move" class="headerlink" title="16.6. Whole Vector Register Move"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">16.6. Whole Vector Register Move</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vmv<nr>r.v 指令可以拷贝整个向量寄存器或向量寄存器组到目的寄存器。</nr></font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">nr值表示向量寄存器的个数</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071210086-bbbccb3d-6a1b-41fe-a760-78c07da236bf.png"></li>
</ul>
<h2 id="17-Exception-Handling"><a href="#17-Exception-Handling" class="headerlink" title="17. Exception Handling"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">17. Exception Handling</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在一条向量指令执行时发生了陷入（可以是异常或者中断触发的），则*epc CSR寄存器会被指向陷入发生的那条向量寄存器的指针所覆盖。此时vstart CSR的内容就是陷入发生时的那个元素的索引</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">vstart CSR是用来允许恢复部分执行的向量指令，以减少中断延迟的。这类似于IBM 3090向量工具中的方案。如果没有vstart CSR，则实现必须保证整个向量指令总是可以在原子上完成，而不产生陷阱。所以vstart实际上允许向量指令在执行期间发生陷入，陷入处理结束后再从新的vstart处继续执行。这是因为很难保证在有stride load/store，scatter/gather操作以及按需分页的虚拟存储器的前提下保证向量指令的原子性。</font></li>
</ul>
<h3 id="17-1-Precise-vector-traps"><a href="#17-1-Precise-vector-traps" class="headerlink" title="17.1. Precise vector traps"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">17.1. Precise vector traps</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">精确的向量陷阱需要：</font></li>
</ul>
<ol>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在陷入发生前的向量指令都需要已经提交了结果</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">比陷入向量指令更加新的指令不能改变架构状态</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">陷入向量指令中影响vstart之前的结果元素的任何操作都提交了它们的结果</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">陷入向量指令中影响vstart处或之后元素的任何操作都不会改变架构状态，除非重新启动和完成受影响的向量指令，否则这些指令不能正确更新架构状态</font></li>
</ol>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">此处我们稍微放宽一些最后一条原则，修改为允许vstart之后的元素在陷入发生后被修改，因为实际上当陷入处理结束，重新从vstart处执行该向量指令时，这些元素就会被覆盖，所以问题不大</font></li>
</ul>
<h3 id="17-2-Imprecise-vector-traps"><a href="#17-2-Imprecise-vector-traps" class="headerlink" title="17.2. Imprecise vector traps"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">17.2. Imprecise vector traps</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">非精确的异常</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">新于<em>epc的指令可以提交结果，旧于</em>epc的指令可以未完成执行</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">不精确陷阱主要用于报告错误和终止执行是适当响应的情况。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">专家可能会指定中断是精确的，而其他陷阱是不精确的。我们假设许多嵌入式实现只会为在致命（fatal）错误上的向量指令生成不精确的陷阱，因为它们不需要可恢复的陷阱。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在当前的标准扩展中，</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">不支持</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">使用不精确的陷阱。</font></li>
</ul>
<h3 id="17-3-Selectable-precise-x2F-imprecise-traps"><a href="#17-3-Selectable-precise-x2F-imprecise-traps" class="headerlink" title="17.3. Selectable precise/imprecise traps"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">17.3. Selectable precise/imprecise traps</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一些专家可能会选择提供一个特权模式位来在精确和不精确的向量陷阱之间进行选择。不精确模式会在高性能下运行，但可能会使其无法识别错误的原因，而精确模式会运行得更慢，但支持错误的调试，尽管有可能不会经历与不精确模式相同的错误。</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在当前的标准扩展中，</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">不支持</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这种模式。</font></li>
</ul>
<h3 id="17-4-Swappable-traps"><a href="#17-4-Swappable-traps" class="headerlink" title="17.4. Swappable traps"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">17.4. Swappable traps</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">另一种陷阱模式可以支持矢量单元中的可交换状态，在陷阱上，特殊指令可以保存和恢复矢量单元的微体系结构状态，以允许在不精确的陷阱周围继续正确执行。</font><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">在当前的标准扩展中，</font><strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">不支持</font></strong><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">这种模式。</font></li>
</ul>
</li>
</ul>
<h2 id="18-Standard-Vector-Extensions"><a href="#18-Standard-Vector-Extensions" class="headerlink" title="18. Standard Vector Extensions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">18. Standard Vector Extensions</font></h2><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">一组用于嵌入式使用的较小扩展用“Zve”命名。而为应用程序处理器设计的一个更大的向量扩展被命名为单字母V扩展。还提供了一个向量长度扩展，名为“Zvl”</font></li>
</ul>
<h3 id="18-1-Zvl-Minimum-Vector-Length-Standard-Extensions"><a href="#18-1-Zvl-Minimum-Vector-Length-Standard-Extensions" class="headerlink" title="18.1. Zvl*: Minimum Vector Length Standard Extensions"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">18.1. Zvl*: Minimum Vector Length Standard Extensions</font></h3><p><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102054935.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">具有更长VLEN的扩展都向下兼容更小VLEN的扩展</font></li>
</ul>
<h3 id="18-2-Zve-Vector-Extensions-for-Embedded-Processors"><a href="#18-2-Zve-Vector-Extensions-for-Embedded-Processors" class="headerlink" title="18.2. Zve*: Vector Extensions for Embedded Processors"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">18.2. Zve*: Vector Extensions for Embedded Processors</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">针对嵌入式领域：</font></li>
</ul>
<p><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102054587.png"></p>
<ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">具有精确的陷阱</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有的向量load/store指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所以向量整数运算</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有向量定点运算</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所以向量整数单宽度和加宽/归约指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有mask指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有序列指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Zve32f和64f需要标量core支持F扩展或Zfinx扩展</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">Zve64d需要标量core支持D扩展或Zdinx扩展</font></li>
</ul>
<h3 id="18-3-V-Vector-Extension-for-Application-Processors"><a href="#18-3-V-Vector-Extension-for-Application-Processors" class="headerlink" title="18.3. V: Vector Extension for Application Processors"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">18.3. V: Vector Extension for Application Processors</font></h3><ul>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">单字一个V是应用级处理器的向量扩展</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">misa.v 会被支持misa和vector的实现置位</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">具有精确的陷阱</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">需要Zvl128b</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持EEW=8,16,32,64</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持vset{i}vl{i}指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有的向量load/store指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所以向量整数运算</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有向量定点运算</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所以向量整数单宽度和加宽/归约指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有mask指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">支持所有序列指令</font></li>
<li><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">需要标量core支持F扩展和D扩展。并实现EEW=32/64的所有浮点向量指令及浮点归约和加宽指令。</font></li>
</ul>
<h2 id="19-Vector-Instruction-Listing"><a href="#19-Vector-Instruction-Listing" class="headerlink" title="19. Vector Instruction Listing"></a><font style="color:rgb(29, 33, 41);background-color:rgb(247, 248, 250);">19. Vector Instruction Listing</font></h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071210230-cee04cbe-00b4-4561-98ce-637e79bb9706.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071210295-0afa1efb-8bec-4fbe-9523-da47660c1204.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071210736-36d85d41-6e21-4d56-8319-dc937f16f023.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42827743/1729071210740-4c1a695a-5f57-41e0-96b8-7f1a6c3792a6.png">  </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://chilh.top">chilh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chilh.top/post/riscv%20v%E6%89%A9%E5%B1%95%E7%BF%BB%E8%AF%91%E6%80%BB%E7%BB%93.html">https://chilh.top/post/riscv%20v%E6%89%A9%E5%B1%95%E7%BF%BB%E8%AF%91%E6%80%BB%E7%BB%93.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chilh.top" target="_blank">Chilh</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102035591.jfif" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2023%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%E7%9A%84%E7%95%99%E8%A8%80.html" title="2023最后一天的留言"><img class="cover" src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202312312339644.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2023最后一天的留言</div></div></a></div><div class="next-post pull-right"><a href="/post/2024-lastday.html" title="2024-总结"><img class="cover" src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202501010045372.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2024-总结</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chilh</div><div class="author-info__description">记录学习笔记，学艺不精，大家多多评论指教</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:1547405085@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Extension-Programmer%E2%80%99s-Model"><span class="toc-number">2.</span> <span class="toc-text">Vector Extension Programmer’s Model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Registers"><span class="toc-number">2.1.</span> <span class="toc-text">Vector Registers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Context-Status-in-mstatus"><span class="toc-number">2.2.</span> <span class="toc-text">Vector Context Status in mstatus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-type-register-vtype"><span class="toc-number">2.3.</span> <span class="toc-text">Vector type register, vtype</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-selected-element-width-vsew-2-0-%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">Vector selected element width vsew[2:0] 每个元素的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Register-Grouping-vlmul-2-0-%E4%B8%80%E4%B8%AAgroup%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">Vector Register Grouping (vlmul[2:0]) 一个group多少个寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Tail-Agnostic-and-Vector-Mask-Agnostic-vta-and-vma"><span class="toc-number">2.3.3.</span> <span class="toc-text">Vector Tail Agnostic and Vector Mask Agnostic vta and vma</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Type-Illegal-vill"><span class="toc-number">2.3.4.</span> <span class="toc-text">Vector Type Illegal vill</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Length-Register-vl"><span class="toc-number">2.4.</span> <span class="toc-text">Vector Length Register, vl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Byte-Length-vlenb"><span class="toc-number">2.5.</span> <span class="toc-text">Vector Byte Length, vlenb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Start-Index-CSR-vstart"><span class="toc-number">2.6.</span> <span class="toc-text">Vector Start Index CSR, vstart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Fixed-Point-Rounding-Mode-Register-vxrm"><span class="toc-number">2.7.</span> <span class="toc-text">Vector Fixed-Point Rounding Mode Register , vxrm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Fixed-Point-Saturation-Flag-vxsat"><span class="toc-number">2.8.</span> <span class="toc-text">Vector Fixed-Point Saturation Flag vxsat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Control-and-Status-Register-vcsr"><span class="toc-number">2.9.</span> <span class="toc-text">Vector Control and Status Register, vcsr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-of-Vector-Extension-at-Reset"><span class="toc-number">2.10.</span> <span class="toc-text">State of Vector Extension at Reset</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mapping-of-Vector-Elements-to-Vector-Register-State"><span class="toc-number">3.</span> <span class="toc-text">Mapping of Vector Elements to Vector Register State</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-for-LMUL-x3D-1"><span class="toc-number">3.1.</span> <span class="toc-text">Mapping for LMUL &#x3D; 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-for-LMUL-lt-1"><span class="toc-number">3.2.</span> <span class="toc-text">Mapping for LMUL &lt; 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-for-LMUL-gt-1"><span class="toc-number">3.3.</span> <span class="toc-text">Mapping for LMUL &gt; 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-across-Mixed-Width-Operations"><span class="toc-number">3.4.</span> <span class="toc-text">Mapping across Mixed-Width Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mask-Register-Layout"><span class="toc-number">3.5.</span> <span class="toc-text">Mask Register Layout</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Instruction-Formats"><span class="toc-number">4.</span> <span class="toc-text">Vector Instruction Formats</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalar-Operands"><span class="toc-number">4.1.</span> <span class="toc-text">Scalar Operands</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Operands"><span class="toc-number">4.2.</span> <span class="toc-text">Vector Operands</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Masking"><span class="toc-number">4.3.</span> <span class="toc-text"> Vector Masking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mask-Encoding"><span class="toc-number">4.4.</span> <span class="toc-text">Mask Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prestart-Active-Inactive-Body-and-Tail-Element-De%C2%8Anitions"><span class="toc-number">4.5.</span> <span class="toc-text">Prestart, Active, Inactive, Body, and Tail Element Denitions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB"><span class="toc-number">4.5.1.</span> <span class="toc-text">元素分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E"><span class="toc-number">4.5.2.</span> <span class="toc-text">特别说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuration-Setting-Instructions-vsetvli-x2F-vsetivli-x2F-vsetvl"><span class="toc-number">5.</span> <span class="toc-text">Configuration-Setting Instructions (vsetvli&#x2F;vsetivli&#x2F;vsetvl)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vtype-encoding"><span class="toc-number">5.1.</span> <span class="toc-text">vtype encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL-encoding"><span class="toc-number">5.2.</span> <span class="toc-text">AVL encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraints-on-Setting-vl"><span class="toc-number">5.3.</span> <span class="toc-text">Constraints on Setting vl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-of-stripmining-and-changes-to-SEW"><span class="toc-number">5.4.</span> <span class="toc-text">Example of stripmining and changes to SEW</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Loads-and-Stores"><span class="toc-number">6.</span> <span class="toc-text">Vector Loads and Stores</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Load-x2F-Store-Instruction-Encoding"><span class="toc-number">6.1.</span> <span class="toc-text">Vector Load&#x2F;Store Instruction Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Load-x2F-Store-Addressing-Modes"><span class="toc-number">6.2.</span> <span class="toc-text">Vector Load&#x2F;Store Addressing Modes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Load-x2F-Store-Width-Encoding"><span class="toc-number">6.2.1.</span> <span class="toc-text">Vector Load&#x2F;Store Width Encoding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Unit-Stride-Instructions"><span class="toc-number">6.2.2.</span> <span class="toc-text">Vector Unit-Stride Instructions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Strided-Instructions"><span class="toc-number">6.2.3.</span> <span class="toc-text">Vector Strided Instructions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Indexed-Instructions"><span class="toc-number">6.2.4.</span> <span class="toc-text">Vector Indexed Instructions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unit-stride-Fault-Only-First-Loads"><span class="toc-number">6.2.5.</span> <span class="toc-text">Unit-stride Fault-Only-First Loads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Load-x2F-Store-Segment-Instructions"><span class="toc-number">6.2.6.</span> <span class="toc-text">Vector Load&#x2F;Store Segment Instructions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Unit-Stride-Segment-Loads-and-Stores"><span class="toc-number">6.2.7.</span> <span class="toc-text">Vector Unit-Stride Segment Loads and Stores</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Strided-Segment-Loads-and-Stores"><span class="toc-number">6.2.8.</span> <span class="toc-text">Vector Strided Segment Loads and Stores</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Indexed-Segment-Loads-and-Stores"><span class="toc-number">6.2.9.</span> <span class="toc-text"> Vector Indexed Segment Loads and Stores</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Load-x2F-Store-Whole-Register-Instructions"><span class="toc-number">6.2.10.</span> <span class="toc-text">Vector Load&#x2F;Store Whole Register Instructions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Memory-Alignment-Constraints"><span class="toc-number">7.</span> <span class="toc-text">Vector Memory Alignment Constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Memory-Consistency-Model"><span class="toc-number">8.</span> <span class="toc-text">Vector Memory Consistency Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Arithmetic-Instruction-Formats"><span class="toc-number">9.</span> <span class="toc-text">Vector Arithmetic Instruction Formats</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Arithmetic-Instruction-encoding"><span class="toc-number">9.1.</span> <span class="toc-text">Vector Arithmetic Instruction encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Widening-Vector-Arithmetic-Instructions"><span class="toc-number">9.2.</span> <span class="toc-text">Widening Vector Arithmetic Instructions </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Narrowing-Vector-Arithmetic-Instructions"><span class="toc-number">9.3.</span> <span class="toc-text">Narrowing Vector Arithmetic Instructions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Integer-Arithmetic-Instructions"><span class="toc-number">10.</span> <span class="toc-text">Vector Integer Arithmetic Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Integer-Add-and-Subtract"><span class="toc-number">10.1.</span> <span class="toc-text">Vector Single-Width Integer Add and Subtract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Integer-Add-x2F-Subtract"><span class="toc-number">10.2.</span> <span class="toc-text">Vector Widening Integer Add&#x2F;Subtract </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Integer-Extension"><span class="toc-number">10.3.</span> <span class="toc-text">Vector Integer Extension</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Integer-Add-with-Carry-x2F-Subtract-with-Borrow-Instructions"><span class="toc-number">10.4.</span> <span class="toc-text">Vector Integer Add-with-Carry &#x2F; Subtract-with-Borrow Instructions </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Bitwise-Logical-Instructions"><span class="toc-number">10.5.</span> <span class="toc-text">Vector Bitwise Logical Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Shift-Instructions"><span class="toc-number">10.6.</span> <span class="toc-text">Vector Single-Width Shift Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Narrowing-Integer-Right-Shift-Instructions"><span class="toc-number">10.7.</span> <span class="toc-text">Vector Narrowing Integer Right Shift Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Integer-Compare-Instructions"><span class="toc-number">10.8.</span> <span class="toc-text">Vector Integer Compare Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Integer-Min-x2F-Max-Instructions"><span class="toc-number">10.9.</span> <span class="toc-text">Vector Integer Min&#x2F;Max Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Integer-Multiply-Instructions"><span class="toc-number">10.10.</span> <span class="toc-text">Vector Single-Width Integer Multiply Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Integer-Divide-Instructions"><span class="toc-number">10.11.</span> <span class="toc-text">Vector Integer Divide Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Integer-Multiply-Instructions"><span class="toc-number">10.12.</span> <span class="toc-text">Vector Widening Integer Multiply Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Integer-Multiply-Add-Instructions"><span class="toc-number">10.13.</span> <span class="toc-text">Vector Single-Width Integer Multiply-Add Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Integer-Multiply-Add-Instructions"><span class="toc-number">10.14.</span> <span class="toc-text">Vector Widening Integer Multiply-Add Instructions </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Integer-Merge-Instructions"><span class="toc-number">10.15.</span> <span class="toc-text">Vector Integer Merge Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Integer-Move-Instructions"><span class="toc-number">10.16.</span> <span class="toc-text">Vector Integer Move Instructions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Fixed-Point-Arithmetic-Instructions"><span class="toc-number">11.</span> <span class="toc-text">Vector Fixed-Point Arithmetic Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Saturating-Add-and-Subtract"><span class="toc-number">11.1.</span> <span class="toc-text">Vector Single-Width Saturating Add and Subtract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Averaging-Add-and-Subtract"><span class="toc-number">11.2.</span> <span class="toc-text">Vector Single-Width Averaging Add and Subtract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Fractional-Multiply-with-Rounding-and-Saturation"><span class="toc-number">11.3.</span> <span class="toc-text">Vector Single-Width Fractional Multiply with Rounding and Saturation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Scaling-Shift-Instructions"><span class="toc-number">11.4.</span> <span class="toc-text">Vector Single-Width Scaling Shift Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Narrowing-Fixed-Point-Clip-Instructions"><span class="toc-number">11.5.</span> <span class="toc-text">Vector Narrowing Fixed-Point Clip Instructions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Floating-Point-Instructions"><span class="toc-number">12.</span> <span class="toc-text">Vector Floating-Point Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Exception-Flags"><span class="toc-number">12.1.</span> <span class="toc-text">Vector Floating-Point Exception Flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Floating-Point-Add-x2F-Subtract-Instructions"><span class="toc-number">12.2.</span> <span class="toc-text">Vector Single-Width Floating-Point Add&#x2F;Subtract Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Floating-Point-Add-x2F-Subtract-Instructions"><span class="toc-number">12.3.</span> <span class="toc-text">Vector Widening Floating-Point Add&#x2F;Subtract Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Floating-Point-Multiply-x2F-Divide-Instructions"><span class="toc-number">12.4.</span> <span class="toc-text">Vector Single-Width Floating-Point Multiply&#x2F;Divide Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Floating-Point-Multiply"><span class="toc-number">12.5.</span> <span class="toc-text">Vector Widening Floating-Point Multiply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Floating-Point-Fused-Multiply-Add-Instructions"><span class="toc-number">12.6.</span> <span class="toc-text">Vector Single-Width Floating-Point Fused Multiply-Add Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Floating-Point-Fused-Multiply-Add-Instructions"><span class="toc-number">12.7.</span> <span class="toc-text">Vector Widening Floating-Point Fused Multiply-Add Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Square-Root-Instruction"><span class="toc-number">12.8.</span> <span class="toc-text">Vector Floating-Point Square-Root Instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Reciprocal-Square-Root-Estimate-Instruction"><span class="toc-number">12.9.</span> <span class="toc-text">Vector Floating-Point Reciprocal Square-Root Estimate Instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Reciprocal-Estimate-Instruction"><span class="toc-number">12.10.</span> <span class="toc-text">Vector Floating-Point Reciprocal Estimate Instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-MIN-x2F-MAX-Instructions"><span class="toc-number">12.11.</span> <span class="toc-text">Vector Floating-Point MIN&#x2F;MAX Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Sign-Injection-Instructions"><span class="toc-number">12.12.</span> <span class="toc-text">Vector Floating-Point Sign-Injection Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Compare-Instructions"><span class="toc-number">12.13.</span> <span class="toc-text">Vector Floating-Point Compare Instructions </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Classify-Instruction"><span class="toc-number">12.14.</span> <span class="toc-text">Vector Floating-Point Classify Instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Merge-Instruction"><span class="toc-number">12.15.</span> <span class="toc-text">Vector Floating-Point Merge Instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Floating-Point-Move-Instruction"><span class="toc-number">12.16.</span> <span class="toc-text">Vector Floating-Point Move Instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Single-Width-Floating-Point-x2F-Integer-Type-Convert-Instructions"><span class="toc-number">12.17.</span> <span class="toc-text">Single-Width Floating-Point&#x2F;Integer Type-Convert Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Widening-Floating-Point-x2F-Integer-Type-Convert-Instructions"><span class="toc-number">12.18.</span> <span class="toc-text">Widening Floating-Point&#x2F;Integer Type-Convert Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Narrowing-Floating-Point-x2F-Integer-Type-Convert-Instructions"><span class="toc-number">12.19.</span> <span class="toc-text">Narrowing Floating-Point&#x2F;Integer Type-Convert Instructions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Reduction-Operations"><span class="toc-number">13.</span> <span class="toc-text">Vector Reduction Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Integer-Reduction-Instructions"><span class="toc-number">13.1.</span> <span class="toc-text">Vector Single-Width Integer Reduction Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Integer-Reduction-Instructions"><span class="toc-number">13.2.</span> <span class="toc-text">Vector Widening Integer Reduction Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Single-Width-Floating-Point-Reduction-Instructions"><span class="toc-number">13.3.</span> <span class="toc-text">Vector Single-Width Floating-Point Reduction Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Ordered-Single-Width-Floating-Point-Sum-Reduction"><span class="toc-number">13.3.1.</span> <span class="toc-text">Vector Ordered Single-Width Floating-Point Sum Reduction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Unordered-Single-Width-Floating-Point-Sum-Reduction"><span class="toc-number">13.3.2.</span> <span class="toc-text">Vector Unordered Single-Width Floating-Point Sum Reduction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-Single-Width-Floating-Point-Max-and-Min-Reductions"><span class="toc-number">13.3.3.</span> <span class="toc-text">Vector Single-Width Floating-Point Max and Min Reductions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Widening-Floating-Point-Reduction-Instructions"><span class="toc-number">13.4.</span> <span class="toc-text">Vector Widening Floating-Point Reduction Instructions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Mask-Instructions"><span class="toc-number">14.</span> <span class="toc-text">Vector Mask Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Mask-Register-Logical-Instructions"><span class="toc-number">14.1.</span> <span class="toc-text">Vector Mask-Register Logical Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-count-population-in-mask-vcpop-m"><span class="toc-number">14.2.</span> <span class="toc-text">Vector count population in mask vcpop.m</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfirst-find-first-set-mask-bit"><span class="toc-number">14.3.</span> <span class="toc-text">vfirst find-first-set mask bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vmsbf-m-set-before-first-mask-bit"><span class="toc-number">14.4.</span> <span class="toc-text">vmsbf.m set-before-first mask bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vmsif-m-set-including-first-mask-bit"><span class="toc-number">14.5.</span> <span class="toc-text">vmsif.m set-including-first mask bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vmsof-m-set-only-first-mask-bit"><span class="toc-number">14.6.</span> <span class="toc-text">vmsof.m set-only-first mask bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-using-vector-mask-instructions"><span class="toc-number">14.7.</span> <span class="toc-text">Example using vector mask instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Iota-Instruction"><span class="toc-number">14.8.</span> <span class="toc-text">Vector Iota Instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Element-Index-Instruction"><span class="toc-number">14.9.</span> <span class="toc-text">Vector Element Index Instruction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-Permutation-Instructions"><span class="toc-number">15.</span> <span class="toc-text">Vector Permutation Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-Integer-Scalar-Move-Instructions"><span class="toc-number">15.1.</span> <span class="toc-text">16.1. Integer Scalar Move Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-Floating-Point-Scalar-Move-Instructions"><span class="toc-number">15.2.</span> <span class="toc-text">16.2. Floating-Point Scalar Move Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-Vector-Slide-Instructions"><span class="toc-number">15.3.</span> <span class="toc-text">16.3. Vector Slide Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-1-Vector-Slideup-Instructions"><span class="toc-number">15.3.1.</span> <span class="toc-text">16.3.1. Vector Slideup Instructions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-2-Vector-Slidedown-Instructions"><span class="toc-number">15.3.2.</span> <span class="toc-text">16.3.2. Vector Slidedown Instructions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-3-Vector-Slide1up"><span class="toc-number">15.3.3.</span> <span class="toc-text">16.3.3. Vector Slide1up</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-4-Vector-Slide1down-Instruction"><span class="toc-number">15.3.4.</span> <span class="toc-text">16.3.4. Vector Slide1down Instruction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-Vector-Register-Gather-Instructions"><span class="toc-number">15.4.</span> <span class="toc-text">16.4. Vector Register Gather Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-Vector-Compress-Instruction"><span class="toc-number">15.5.</span> <span class="toc-text">16.5. Vector Compress Instruction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-1-Synthesizing-vdecompress"><span class="toc-number">15.5.1.</span> <span class="toc-text">16.5.1. Synthesizing vdecompress</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-Whole-Vector-Register-Move"><span class="toc-number">15.6.</span> <span class="toc-text">16.6. Whole Vector Register Move</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Exception-Handling"><span class="toc-number">16.</span> <span class="toc-text">17. Exception Handling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-Precise-vector-traps"><span class="toc-number">16.1.</span> <span class="toc-text">17.1. Precise vector traps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-Imprecise-vector-traps"><span class="toc-number">16.2.</span> <span class="toc-text">17.2. Imprecise vector traps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-Selectable-precise-x2F-imprecise-traps"><span class="toc-number">16.3.</span> <span class="toc-text">17.3. Selectable precise&#x2F;imprecise traps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-Swappable-traps"><span class="toc-number">16.4.</span> <span class="toc-text">17.4. Swappable traps</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Standard-Vector-Extensions"><span class="toc-number">17.</span> <span class="toc-text">18. Standard Vector Extensions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-Zvl-Minimum-Vector-Length-Standard-Extensions"><span class="toc-number">17.1.</span> <span class="toc-text">18.1. Zvl*: Minimum Vector Length Standard Extensions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-Zve-Vector-Extensions-for-Embedded-Processors"><span class="toc-number">17.2.</span> <span class="toc-text">18.2. Zve*: Vector Extensions for Embedded Processors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-V-Vector-Extension-for-Application-Processors"><span class="toc-number">17.3.</span> <span class="toc-text">18.3. V: Vector Extension for Application Processors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Vector-Instruction-Listing"><span class="toc-number">18.</span> <span class="toc-text">19. Vector Instruction Listing</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/arm%E4%B8%93%E5%88%A9%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%80.html" title="arm专利分析系列&lt;一&gt;"><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/20251216234835959.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="arm专利分析系列&lt;一&gt;"/></a><div class="content"><a class="title" href="/post/arm%E4%B8%93%E5%88%A9%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-%E4%B8%80.html" title="arm专利分析系列&lt;一&gt;">arm专利分析系列&lt;一&gt;</a><time datetime="2025-12-16T15:28:33.000Z" title="发表于 2025-12-16 23:28:33">2025-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%951-%E7%B2%97%E9%A2%97%E7%B2%92%E7%AD%96%E7%95%A5.html" title="缓存替换算法"><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202505112103982.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存替换算法"/></a><div class="content"><a class="title" href="/post/%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%951-%E7%B2%97%E9%A2%97%E7%B2%92%E7%AD%96%E7%95%A5.html" title="缓存替换算法">缓存替换算法</a><time datetime="2025-01-21T06:33:23.000Z" title="发表于 2025-01-21 14:33:23">2025-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%950.html" title="Cache Replacement Policies - introduction"><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202505112103982.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cache Replacement Policies - introduction"/></a><div class="content"><a class="title" href="/post/%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%950.html" title="Cache Replacement Policies - introduction">Cache Replacement Policies - introduction</a><time datetime="2025-01-20T11:24:52.000Z" title="发表于 2025-01-20 19:24:52">2025-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%952-%E7%BB%86%E9%A2%97%E7%B2%92%E7%AD%96%E7%95%A5.html" title="缓存替换算法"><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202505112103982.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存替换算法"/></a><div class="content"><a class="title" href="/post/%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%952-%E7%BB%86%E9%A2%97%E7%B2%92%E7%AD%96%E7%95%A5.html" title="缓存替换算法">缓存替换算法</a><time datetime="2025-01-20T11:24:52.000Z" title="发表于 2025-01-20 19:24:52">2025-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2024-lastday.html" title="2024-总结"><img src="https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202501010045372.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024-总结"/></a><div class="content"><a class="title" href="/post/2024-lastday.html" title="2024-总结">2024-总结</a><time datetime="2024-12-31T14:59:00.000Z" title="发表于 2024-12-31 22:59:00">2024-12-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://chilh-1311344212.cos.ap-beijing.myqcloud.com/picture/202411102035591.jfif')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By chilh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadWaline () {
  function insertCSS () {
    const link = document.createElement("link")
    link.rel = "stylesheet"
    link.href = "https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css"
    document.head.appendChild(link)
  }

  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://chilh-comment-nwkfkyqk8-zhanzghouhe.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'function') initWaline()
  else {
    insertCSS()
    getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":85,"height":400,"hOffset":-18,"vOffset":25},"mobile":{"show":true},"react":{"opacity":0.7},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>